## TIL

## 시스템 소프트웨어

### 운영체제, Unix, Linux
- Unix
  - C언어로 프로그램된 OS
  - Unix의 핵심 구성 : Kernel, File System...
- Linux
  - 리누스 토발즈가 만든 Unix 클론
  - 유사 Unix 운영체제 + 다양한 유틸리티(컴파일러, 네트워크 등...)
    - 컴파일러 : C(gcc), C++
    - 네트워크 유틸리티 : ftp, ssh, ping ...
  - 현제 전 세계적으로 매우 다양한 배포판 존재
  - 대표적인 Linux 배포판 : 레드햇(RedHat), 우분투(Ubuntu) ...

### 리눅스 파일 시스템
- Sector : 물리적인 Disk의 가장 작은 단위(cf. Block이 논리적 단위)
- 참고) Disk 저장 구조
  - Surface, Track, Sector, Cylinder

- File System
  - 운영체제가 파일을 저장하고 관리하기 위한 방법
  - 디렉토리로 파일을 계층적으로 관리
  - 파일과 파일의 메타데이터(inode), 디렉토리 정보 등을 관리
    - 메타 데이터 : 파일을 관리하기 위한 각종 정보

- File
  - 정의 : A named collection of related information
  - 디스크에 저장된 정보를 관리하기 위한 추상적(논리적) 단위
  - 파일은 여러개의 연속적/비연속적인 Block으로 이루어져있음
    - 사용자가 한 File을 구성하는 모든 Block의 고유 번호를 알고 있을 수 없으므로, File이라는 추상적 단위로 OS가 관리해줌
  - 일반적으로 비휘발성인 보조기억장치(Disk-HDD, SSD, USB ...)에 저장

- Block
  - 파일이 저장되는 기본 단위. 논리적 단위
  - Block의 크기는 각 시스템마다 정의된 크기가 있음
  - 마치 주소를 가진 1차원 배열처럼 취급

- Directory
  - 리눅스 파일 시스템 트리
    - root(/)부터 시작해서 뻗어나가는 계층적 구조
      - root(/)부터 시작해서 원하는 파일까지 쭉 따라가면서, 해당 파일의 Inode를 찾아감
    - 디렉토리
      - 우리가 아는 폴더 개념
      - 파일의 메타데이터 중 일부만을 보관하고 있는 특수한 파일
      - 그 디렉토리에 속한 파일의 이름 및 파일 attributes 리스트
  - 특정 사용자로 로그인 시, 사용자의 Home Directory(~)에서 시작

- Unix File System
  - Boot block : 부팅에 필요한 정보
  - Super block : 전체적인 파일 시스템에 대한 정보
  - inode : 파일의 메타 데이터를 담고있는 자료구조
    - 파일은 각자 1개의 inode를 갖고 있음
    - 소유자, 그룹, 접근 권한(rwx), 파일 형태(일반, 디렉토리), i-number(inode number), 파일 크기, 마지막 접근 or 수정 시각, 등 해당 파일에 관한 정보를 갖고 있음
    - 파일 시스템 내의 파일은 각자 고유한 inode-number를 갖고 있음
    - 파일 시스템을 생성할 때 전체 공간의 약 1%를 inode를 위해 할당함
  - Data block : 파일의 실제 내용

- 리눅스의 경로
  - 절대 경로(absolute path)
    - 로컬 PC(내 컴퓨터)를 기준으로 한 경로(Full path, 변하지 않는 고유 경로)
    - 예) Window: `c:\User\image\cat.jpg`
    - Mac(Linux) : `/Users/easy/Desktop/zerobase-fe-html-css-summary/3_HTML_Tags/images/cat.jpg`
  - 상대 경로(relative path)
    - 현재 작성중인 파일을 기준으로 상대적으로 표현한 경로
    - 상대 경로 표현 방법
      - /(슬래쉬)로 디렉토리 구분
      - .(점 하나) : 현재 디렉토리
      - ..(점 두개) : 부모 디렉토리
    - 기본적으로 항상 `./`가 생략되어있기 때문에, 파일명을 아무것도 없이 그냥 작성하면 현재 디렉토리에서 이미지를 가져오게 됨
  - ~ : 현재 사용자의 홈 디렉토리
- 예시
  - 2002.txt
    - 절대경로 : /Users/easy/zerobase-cs-linux/2002.txt
    - script1.sh 기준 상대경로 : ./2002.txt
    - b.txt(test3 하위) 기준 상대 경로 : ../../2002.txt

### 주요 리눅스 명령어 1
- 쉘(Shell, CLI) : Linux(Unix)에서 사용하는 사용자가 커널(운영체제)를 조작할 수 있도록 인터페이스를 제공하는 응용 프로그램
  - 사용자의 입력(명령어)를 해석하여 Kernel에 전달
  - 터미널에서 -> Shell이 실행됨(bash, zsh, ...) -> 사용자가 명령어를 입력 -> Shell이 명령어를 해석 -> Shell이 미리 작성된 명령어 별 프로그램 실행 -> 실행 중에 시스템콜 호출 -> 커널에서 명령을 수행하기 위한 동작 실행 -> 명령 실행 -> 결과를 표준 출력으로 출력
- 리눅스 명령어 알아야 할 내용
  - 모든 명령어, 옵션간 구분은 공백(스페이스바)
  - [] : optional, 입력 해도 되고 안해도 되는 선택적인 것
  - 아무것도 없으면 : 명령어 문법 상 반드시 입력해야 하는 것
  - Ctrl + C : 작업중인 프로세스 강제 종료
  - 옵션은 여러개를 이어붙여서 사용할 수 있음
  - 파일명, 디렉토리명은 상대 경로와 절대 경로 형태 상관없이 모두 가능
  - sudo를 모든 명령어 맨 앞에 붙이면 : root 권한으로 실행

- `pwd` : Print Working Directory, 현재 작업중인 디렉토리 출력
- `ls` : 현재 디렉토리의 모든 파일 출력
  - ls [-옵션][디렉토리 이름 or 파일명]
  - 주요 옵션
    - `-a` : all, 숨김 파일까지 나열 (예) .gitignore, .bashrc
    - `-l` : long, 긴 목록 출력. 파일의 접근 권한, 소유권, 최종 변경일자 등
    - `-R`: 디렉토리 내용과 서브 디렉토리 내용까지 재귀적으로 출력

- `cat` : 표준 입력(키보드)또는 파일이름을 받아서 -> 표준 출력(화면)으로 출력
  - cat[파일명] : 파일의 내용을 화면에 출력
  - cat: 표준 입력(키보드)을 화면에 출력
    - 입력을 그만하라면 Ctrl + C
  - cat > 파일명 : >(리다이렉션)으로 출력의 방향을 바꿔서, 표준 입력으로 입력을 받아서 파일에 저장함

- `whoami` : 현재 사용자가 누구인지 출력

- `head` : 파일 처음부터 n줄까지 출력
  - head[-n] 파일명
  - `-n` : n번째 라인까지 출력. default=10
- `tail` : 파일의 마지막 n줄부터 출력
  - tail[-n] 파일명
- `mkdir` : 디렉토리 생성
  - mkdir 디렉토리명
    - 디렉토리명은 상대 경로, 절대 경로 모두 들어갈 수 있음
    - 이름만 딱 쓰면, 현재 경로 하위에 생성됨(why? 상대경로는 기본적으로 `./`가 생략되어있기 때문

- `cd` : Change Directory. 다른 디렉토리로 이동
  - cd[디렉토리명] : 해당 디렉토리로 이동
  - 디렉토리명을 입력하지 않은 경우 사용자의 홈 디렉토리(~)로 이동

### 주요 리눅스 명령어 2
- `mv` : 파일의 위치 이동 또는 파일의 이름 변경
  - mv Source Dest
  - mv 파일명(A) 디렉토리명(B) : 파일A를 디렉토리B로 하위로 이동
  - mv 파일명(A) 파일명(B) : A 파일의 이름을 B로 변경
  - mv 디렉토리명(A) 디렉토리명(B) : A 디렉토리의 이름을 B로 변경
- `cp` : 파일 복사. Copy
  - cp Source Dest
  - cp 파일명(A) 파일명(B) : 파일 A를 복사하여 (같은 위치에) 파일 B 생성
  - cp 파일명(A) 디렉토리명(B) : 파일 A를 디렉토리 B 하위에 복사
  - cp -r 디렉토리명(A) 디렉토리명(B) : 디렉토리 A에 있는 모든 파일과 서브 디렉토리를 재귀적으로 디렉토리 B에 복사

- `rm` : 파일 삭제
  - rm[-옵션]파일명
  - 주요 옵션
    - `-f` : 강제 삭제(리눅스에는 휴지통개념이 없으므로 주의)
    - `-r` : 서브디렉토리를 포함하여 재귀적으로 삭제
  - 참고) rm * 해당 디렉토리 내 모든 파일 삭제

### 주요 리눅스 명령어 3
- `chmod` : 파일의 접근 권한 변경(change mode의 약자)
  - File의 접근 권한 표현 방법
    - 권한 적용 대상 : 3자리 묶어서 User / Group / Others
    - 권한 종류 : 각각 한 자리씩 Read(읽기 권한) / Write(쓰기 권한) / Execute(실행 권한)
  - chmod [-R] mode 파일 이름
  - `-R`: 디렉토리 내에 있는 파일의 모드를 재귀적으로 변경
  - 방법 1 : mode
    - 대상+권한종류 : 특정 대상에게 특정 권한 부여
    - 대상-권한종류 : 특정 대상의 특정 권한 회수
    - 대상 : u, g, o, a(all)
    - 허가권 : r, w, x
  - 방법 2 : 10진수 3자리 숫자
    - 각 숫자는 각 대상(u,g,o)의 허가권을 나타냄
      - 10진수를 2진수로 변환하여 해석
    - 예 1) 750 -> 111 101 000 -> user는 rwx가능, group은 r,x가능, others는 불가능
    - 예 2) 777 -> 111 111 111 -> 모든 사용자가 모든 권한 보유 -> 가장 취약한 권한
   
  - `ps` : 현재 동작중인 프로세스 목록 출력
    - ps [옵션] / [-옵션]
    - 주요 옵션 : 옵션이 매우 많으므로 필요할 떄 찾아보기, 자주 쓰는 것은 ps -ef 또는 ps aux 정도
      - `x`: 자신이 사용하는 모든 프로세스 출력
      - `aux` : 시스템에서 동작하는 모든 프로세스들을 출력(다른 사용자들의 프로세스까지 모두)
      - `ps - ef | grep 검색어`
        - 파이프(|)로 앞 명령어의 출력을 다음 명령의 입력으로 씀
        - `grep` : 문자열 검색을 위한 명령어

- `kill`: 프로세스 종료
  - kill [옵션] 프로세스 ID(PID)
  - kill -9 PID 
- 프로세스의 foreground, backgroudn 실행
  - foreground : 현재 터미널에서 수행(표준 입출력 가능)
  - background : 모든 명령어 맨 뒤에 &를 붙이면 background로 프로세스 수행(화면 창을 장악하지 않고 안보이게 수행)

### VI 에디터
- Vi Editor : 전통적인 유닉스의 텍스트 에디터
- Vi의 모드는 명령모드와 입력모드가 있음
  - 맨 처음에 실행시키면 명령모드
  - 명령모드 -> 입력모드 : i키 누르기
  - 입력모드 -> 명령모드 : ESC키 누르기
- 사용법 : vi[파일명]
  - 참고) vim은 vi의 improve 버전
- 명령모드에서의 파일의 저장과 종료
  - `:w` : (임시)저장
  - `:q` : 종료
  - `:wq`: 저장하고 종료
  - `:q!`: 강제 종료(저장하지 않고 종료)

### 쉘 스크립트
- Shell은 두가지 의미가 있음
  1. 명령어를 이해하고 실행할 수 있는 응용 프로그램
  2. 시스템 프로그래밍을 위한 프로그래밍 언어
- Shell언어로 프로그래밍을 하여 시스템(OS)를 조작하는 Shell 스크립트를 작성할 수 있음 -> 시스템 프로그램 개발
  - 리눅스 서버 상의 편리한 빌드, 배포, 운영을 위해 사용할 수 있음
  - 처음부터 끝까지 작성할 줄 아는 능력(Advanced)을 목표로 하기 보다는, 쉘 스크립트를 보고 술술 이해할 수 있도록
- 기본 내용
  - 파일의 가장 첫번쨰 라인은 #!/bin/bash로 시작
    - #! 뒤에 path명이 들어가는데, 누가(어떤 Shell)이 script를 해석할 것인지 지목하는 것
  - 파일 포맷은 .sh
  - 실행하려면 실행권한(x)이 있어야 함(executable)
  - 실행 방법
    1. (그냥) 파일명 : 실행권한이 있는 경우 파일명을 마치 명령어처럼 실행
    2. sh 파일명

- 기본 문법
  - 주석 : #로 시작
  - 변수 선언
    - 변수명=값
    - 주의)=앞 뒤에 공백이 있으면 안된다
  - 기본 argument
    - $0 : shell script의 이름
    - $1, $2, ..., $n : n번쨰 argument
    - $#: 들어온 arguments의 수
  - 조건 연산자
    - 주의)[]의 앞뒤에 무조건 공백이 들어가야 함
    - if [조건] then ~ fi
    - if [조건] then ~ else ~ fi
    - if [조건] then ~ elif [조건] ~ else ~fi
  - 비교 연산
    - 문자열 비교 : =(같다), !=(같지 않다)
    - 산술 비교 : -eq(같다), -ne(같지 않다), -gt(크다), -ge(크거나 같다), -lt(작다), -le(작거나 같다)
    - 파일 관련 : -e 파일명(파일이 존재하는지), -d(디렉토리가 존재하는지)...
  - 반복문
    - for : for 변수 in [값 목록] do ~ done
    - while : while [조건] do ~ done
