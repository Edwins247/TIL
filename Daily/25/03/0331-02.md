## TIL

## 컴퓨터 구조

### 컴퓨터의 구성
- 폰노이만 구조 : 현대에 범용적으로 쓰이는 컴퓨터 구조
  - 현대 대부분의 컴퓨터가 폰 노이만 구조를 바탕으로 설계되어 있음
  - 과정
    - Input이 들어가면 -> 처리를 해서 -> Output이 나온다.
    - 처리 과정 : 메모리에 실행할 프로그램을 올린다 -> Control Unit에서 명령어를 하나씩 꺼내서 해석한다 -> ALU에서 연산한다 -> 연산 결과를 메모리에 쓴다 -> (출력 장치로 내보낸다)
      1. Fetch : 메모리에서 명령어를 가져오는 것
      2. Decode : Control Unit에서 명령어를 해석하고 적절한 제어 신호를 보낸다.
      3. Execution : 실제로 연산을 실행
      4. Write Back : 연산 결과를 저장(메모리, 레지스터 등)
    - 인간의 사고 과정과 유사함 : 어떤 연산을 마주했을 때, 머릿속의 기억을 불러와서 계산하는 과정
      - 예) 오늘 점심 얼마 나왔지?(Program) -> 음..(CPU) 피자 2만원, 햄버거 1만원(Memory) -> 총 3만원이야(CPU) -> 3만원을 낸다(Output)

- 컴퓨터의 구성 요소
  1. CPU
     - Central Processing Unit의 약어. 중앙 처리 장치
     - 컴퓨터의 두뇌
  2. Memory
     - 데이터(Data)와 명령어(Code)를 저장하는 공간
  3. Program
     - 실행할 명령어의 모음
  4. I/O Devices(입출력 장치)
     - I/O란 Input/Output의 줄임말로, 입출력을 의미
     - 입력 장치 : 키보드, 마우스, 마이크
     - 출력 장치 : 스피커, 모니터, 프린터
  5. 참고)버스(Bus)
     - 데이터를 읽고, 쓰기 위해 주고받는 통로가 필요함
     - CPU, Memory, I/O Devices를 연결해주는 통로
    
### CPU
- 컴퓨터의 두뇌! Central Processing Unit의 약어. 중앙 처리 장치
- CPU와 Processor는 같은 의미로 이해해도 된다.
- 역할
  1) 제어 : 컴퓨터의 부품과 정보를 주고받으면서, 컴퓨터 시스템 전체를 제어
  2) 연산 : 프로그램의 연산을 실행
- CPU의 구성
  - 제어 장치(Control Unit, CU) : 명령어를 해석하고, 각 부품에 명령을 내려서 메모리, I/O 장치 등을 제어함
  - 산술/논리 장치(Arithmetic/Logic Unit, ALU) : 비교, 판단, 산술 연산을 수행함
    - 산술 연산 : 더하기에서 파생되는 사칙연산 등 수학적인 연산
    - 논리 연산 : AND, OR, NOT등 비교와 판단
  - 레지스터(Register) : 빠른 연산의 실행을 위해 제공되는 아주 작고 빠른 기억 장치
    - 메모리 -> 레지스터 -> CPU(Load & Store)
    - 범용 레지스터 : 일반적으로 CPU 연산시 사용되는 데이터들을 임시 보관하는 공간
    - 용도 지정 레지스터
      - PC(Program Counter)란? 다음 실행시킬 명령어의 주소를 가리키는 레지스터
      - IR: 현재 수행중인 명령어를 저장하고 있는 레지스터
      - SP: Stack Pointer(stack 자료구조, push, pop)
  - L1, L2, L3 캐시, 내부 버스 등 부가 장비
- 참고) 파이프라이닝(Pipelining, Intsruction Pipeline)
  - CPU의 성능을 높이기 위한 기법
    - 한 번에 하나의 명령어만 실행하는 것이 아니라, 하나의 명령어가 실행되는 도중에 다른 명령어 실행을 시작하는 방식으로 동시에 여러개의 명령어를 실행하는 기법
  - 명령어는 순차 실행되기 때문에, 한 명령어의 실행이 끝날 때까지 다른 명령어들을 기다려야함
    - CPU의 특정 파트가 놀고 있으므로 시간/자원의 낭비임
  - 이러한 낭비를 줄이기 위해, 명령어 실행 단계를 여러 단계로 나누고, 각 단계가 끝나고 해당 부품이 놀게되면, 바로 다음 명령어가 실행되도록 하는 것이 파이프라이닝
  - 명령어가 끝나는 총 cycle수를 줄일 수 있음
    - 예) 5개 명령어, 한 명령마다 5단계
      - 파이프라이닝 X : 5 * 5 = 25 cycles
      - 파이프라이닝 O : 9 cycles
     
### 메모리와 계층 구조
- Memory란?
  - 데이터(Data)와 명령어(Code)를 저장하는 공간
  - 주기억장치 : 레지스터, 메인 메모리(램, RAM, DRAM), 캐시 등
    - 컴퓨터가 꺼지면 날아간다(휘발성)
    - 예) 복사 붙여넣기 할 때 쓰는 클립보드에 있는 데이터는 컴퓨터를 끄면 날아간다.
  - 보조기억장치 : Disk(HDD, SSD), 외부스토리지, CD, USB 등
    - 컴퓨터가 꺼져도 날아가지 않는다(비휘발성)
    - 예) 데스크탑(바탕화면)이나 C드라이브에 저장한 파일은 컴퓨터를 껐다 켜도 남아있다.
- 메모리 계층 구조
  - 아래로 갈수록
    - 느리고(접근시간(cycle)이 느리다, 성능 down)
    - 저렴하고
    - 용량이 크다
   
### 캐시 메모리
- 캐시란? CPU에서 필요한 데이터를 Main Memory에서 가져오는 것보다 빠르게 접근하기 위한 작고 빠른 임시 공간
- 캐시 접근 시간(속도) <<<<< 메모리 접근 시간(속도)
  - 캐시에 데이터를 미리 복사하여 저장 -> 연산 시 더 빠르게 데이터에 접근 가능 => 효율성을 높여 CPU 성능을 높임
- 캐시는 여러 레벨이 있으며 레벨이 작을수록 가장 연산 유닛과 가깝고, 빠르고, 공간이 작음
  - L1 캐시, L2 캐시, L3 캐시, ... <- CPU 내부
- 캐시 동작 과정
  1. A라는 데이터가 필요하다.
  2. 캐시를 확인한다.
  3. 캐시가 있다면(Hit)? 캐시의 데이터를 읽는다.
  4. 캐시가 없다면(Miss)? Memory(Disk)에서 데이터를 가져와서 전달하고, 캐시에 쓴다.
- 참고) Direct-Mapped Cache, Set Associative Cache, ...

- 지역성(Locality)이란?
  - 캐시가 효율적으로 동작하려면, 캐시에 데이터를 저장할 때 지역성을 고려해야함
  - 시간적 지역성 : 특정 데이터가 한 번 접근되었으면, 가까운 미래에 또 한 번 그 데이터에 접근할 가능성이 높다.
  - 공간적 지역성 : 특정 데이터가 한 번 접근되었으면, 그 데이터와 가까운 주소의 데이터에 접근할 가능성이 높다.
- 캐시교체 알고리즘(페이지 교체 알고리즘)
  - 캐시 공간은 한정적이기 때문에, 꽉 차면 기존에 저장된 데이터를 내보내고, 새로운 데이터를 써야함
    - 그런데, 어떤 데이터를 지워버릴 것인가? -> 이걸 판단하는 알고리즘이 캐시 교체 알고리즘
  - LRU(Least Recently Used) : 가장 과거에(덜 최근에) 접근된 것이 나간다
  - LFU(Least Frequently Used) : 가장 덜 자주 접근된 것이 나간다
 
### 프로그램 실행 과정
- Program이란? 컴퓨터에서 실행될 특정 작업(Task, Job)을 수행하기 위한 명령어의 집합
  - 명령어(Instruction)란 컴퓨터의 언어, HW와 SW의 인터페이스
  - 디스크에 파일 형태로 저장되어 있다가, 사용자가 실행시키면 메모리로 적재되어 실행된다.

- 우리가 고급 언어로 작성한 프로그램을 컴퓨터가 어떻게 이해하는가?
- 고급 언어에서 기계어로
  - 고급 언어(High Level Language) : 인간에게 가장 가까운 프로그래밍 언어 C, Python...
  - 어셈블리어(assembly language) : 기계어와 일대일로 대응되는 저급 언어
  - 기계어(Machine Language) : CPU가 직접 해석할 수 있는 0과 1(bit)로 이루어진 가장 저급 언어
  - 참고) 컴퓨터 구조에 따라 사용하는 어셈블리어와 기계어가 달라진다.
    - Intel등 각 제조사마다 Instruction Code(opcode)의 집합이 정해져 있음 -> Instruction Set Architecture
    - 제조사마다 opcode가 달라서 연산을 해석하는 방식이 아예 다르다.
   
- 컴파일 언어와 인터프리터 언어
  - 컴파일 언어 : C, C++,...
  - 인터프리터 언어 : Python, JavaScript, ...
  - 차이점
    - 컴파일 언어는 미리 전체 코드를 기계어로 변환(컴파일, 빌드)한 후 실행. 빠르다
    - 인터프리터 언어 : 코드를 한줄씩 읽으면서 해석하여 실행되는 프로그램. 느리다. 수정이 간단하다.

### 비트, 이진법, 16진법
- bit: 0 or 1, 0은 OFF, 1은 ON. 컴퓨터가 인식할 수 있는 단위, 컴퓨터의 모든 명렁어는 0과 1의 조합으로 이루어져 있음
- 이진법이란?
  - 0과 1로 수를 표현하는 방법
  - 우리가 일상에서 사용하는 수를 표현하는 방법은 10진법
  - 2진수를 10진수로 바꾸는 법, 10진수를 2진수로 바꾸는 법은 개발자로서 기본 중에 기본

- 16진법(base 16) : 컴퓨터에서 이진수 대신 많이 쓰이는 기수법
  - 0~15까지의 숫자로 수를 표현하는 방법
    - 0~9까지의 수, 10부터는 A-F
    - 오른쪽에서 왼쪽 방향으로 표현
    - 이진수를 4자리씩 묶어서 16진수로 표현
    - 예) 11995 -> 10111011011011 -> 10 1110 1101 1011 -> 2EDB
   
- 32bit 컴퓨터? 64bit 컴퓨터?
  - 32bit 컴퓨터 == 32bit 주소 체계 사용 == 표현 가능한 수의 범위가 0 ~ 2^32
  - 컴퓨터 구조를 배울 때, 주로 8bit, 16bit, 32bit 시스템을 가정하고, 명령어(HW와 SW의 인터페이스)와 주소 체계가 8bit, 16bit, 32bit로 되어있는 컴퓨터의 동작을 배움
    - 메모리의 공간은 '주소'가 부여되어 있고, 이 '주소'를 바탕으로 연산을 하나씩 수행함
    - 해당 '주소'의 레지스터, 메모리 등에 데이터를 읽고 쓰는 원리
   
