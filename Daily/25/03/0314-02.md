## TIL

### 숫자 리터럴
- JS는 기본적으로 숫자에 있어서 IEEE 754라는 부동소수점을 기준으로 숫자값을 처리함
- 사람은 정수로 생각하고 컴퓨터는 2진수로 생각하기 떄문에, 이를 위해서 부동소수점 방식으로 컴퓨터가 사람이 쓴 값에 대해서 이해를 함
- 그 외에, 16진수(0xFF), 지수(5e2) 등의 값도 표현해서 처리할 수 있음
- 하지만, 실수를 직접적으로 다루기 전까지는 최소한의 구동 방식을 이해하면 됨
- 그리고 숫자 검사의 경우 `isNaN`을 활용해서 체크하면 됨
- 숫자 리터럴은 말 그대로 `const num = 123` 직관적으로 숫자를 쓰는것을 의미함(어차피 래퍼 객체가 이에 대해 알아서 숫자 처리나 다양하게 활 수 있음)
- 가령 `num.toFixed` 같이 바로 함수를 쓸 수 있음(래퍼 객체의 여러)

### 숫자로 변환
```js
Number(undefined) // NaN
Number(null) // 0
Number('') // 0
Number('String')// NaN
Number(true) // 1
Number(false) // 0
Number(3.141592) // 3.141592
```
- 위처럼 Number 변환시 특히, undefined, null, ' '등 값이 위와 같이 변환됨을 알면 좋음
- 이 때 명시적으로 `+true`등으로 전환시 1로 숫자로 변환됨
- 결과적으로 명시적으로 숫자 변환을 직접 하는게 나음 위의 예시와 같이, 이를 꼼수나 느슨한 연결을 통해서 쓰면 안 좋음

### Not a Number
- `NaN`, `Number.NaN`이 같은데, 이는 숫자가 아님을 의미하는 뜻임
- 아래의 예시의 경우 NaN이 출력이 됨, 즉 Not a Number를 js에서 인정하는 것을 말함
```js
Number(undefined);
parseInt('숫자로 변환 불가능한 문자열');
Math.log(-1);
10 + NaN;
"가나다라" / 10; // 문자 + 숫자의 경우 문자열로 변환되는데, 더하기 연산이 아닌 경우는 NaN이 됨
```
- 어쩔 수 없는 상황에서 NaN을 마주할 수 있기에 알아두는게 좋음, 판별하는 메소드를 활용해서 처리할 수도 있음

### Infinity
- 너무 크거나 작다 이럴 때 나타나는 숫자, 지수 1023까지만 허용함(NaN 보다 더 많이 볼 수 있음)
- 아래의 예시의 경우 Infinity가 뜸(불가능한 연산, 지수 1023을 넘는 경우)
```js
Math.pow(2, 1024);
7 / 0;
```
- 중요한 것은 위의 NaN도 그렇고 Infinity도 그렇고 오류로 인정되는 것이 아님을 알아야함
- `isFinite` 함수를 통해서 해당 값이 실제 숫자인지 확인할 수 있음(NaN도 포함)
- 일반적인 숫자인지 체크할 수 있기 일반적인 숫자인 경우는 true를 반환함

### BigInt
- JS는 숫자가 부동소수점으로 움직이기 때문에 이에 대해서 커버를 할 수 있는 값이 있음
- 가령 `Number.MAX_VALUE`와 같이, JS 표현할 수 있는 가장 큰 숫자를 나타냄(Number.MAX_SAFE_INTEGER 포함)
- 위의 2가지 함수는 안전한 숫자와 큰 숫자를 나타냄
- 하지만 이때, 위의 숫자는 너무 크고 알아보기도 힘든데 BigInt의 경우 Number 원시값이 안정적으로 나타낼 수 있는 최대치를 커버함
- 아래 예시처럼 쓴다면 엄청 큰 숫자도 부동소수점이 아닌 직관적으로 쉽게 볼 수 있음
- BigInt는 완전히 Number와 일치하지 않지만 느슨한 비교에선 true이긴함
- 불가피하게 큰 숫자를 다룰 때 BigInt를 쓰는걸 권장
```js
// n을 붙이거나 BigInt로 감싸서 표현
console.log(123123123123123123123123123123n);
BigInt(123123123123123123123123123123);
```
- [참고자료](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

### 정수
- 정수(Integer)의 경우, JS는 부동소수점만 존재함
- 이에 대해서 정수를 저장하는 2가지 방법이 있음
- 먼저 10진 소수가 없는 작은 숫자는 정수로 오래 유지함 ex) 31비트, 혹은 비트 연산자를 이용해 32비트 정수로 바꿔 변환함
- 정수를 다루기 어려워서 `Number.`을 기점으로 안전한 정수의 최대값과 최소값을 제공함(MAX_SAFE_INTEGER, MIN_SAFE_INTEGER)
- 이 때, 정수로 바꾸는 방법에 있어서 아래의 예시의 메소드 Math 메소드를 활용해서 변환할 수 있음
```js
// 소수점을 다루는 방법
Math.floor(4.2) // 가장 가까운 정수로 내리기
Math.ceil(4.9) // 가장 가까운 정수로 올리기
Math.round(4.6) // 가장 가까운 정수로 반올림
```

### 정수로 변환
- Number로 정수를 변환할 수 있지만 `parseInt`로 변환할 수 있음
- `Number.isInteger` 함수를 통해서 앞서 정수가 맞는지 확인할 수도 있음(`isSafeInteger` 포함)
- 이처럼 정수가 맞는지 철저하게 확인하는 함수들임
- 이 때 `parseInt`의 경우, 몇 진수로 변환할 지, 그 값에 대해서 선택적으로 쓸 수 있음
- 대부분 10진수를 기대하는데, 2번째 인자를 몇 진수인지 같이 쓰는것이 좋음

### 산술 연산자
- `+`, `-`, `/`, `*` 등 계산을 할 수 있음
- 여기서 `%` 나머지 연산도 할 수 있음(홀짝, 실수 다룰 때 많이 쓰기도 함)
- 추가로 증감연산자도 존재함, 하지만 주의할 점이 예시와 같이 있음
```js
let x = 5;

// 바로 더하기 뺴기 진행
++x
--x

// 할당부터하고 값을 계산
x++
x--
```
- 그래서 직관적으로 알아볼 수 있는 케이스를 가지고 적용하는게 좋음
- 그리고 연산자 우선순위가 존재함, 괄호로 감싼 연산부터 실행함, 그래서 직관적으로 쓰는것이 좋음
- [참고자료](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence)

### Number.isNaN()
- Not a Number는 숫자로 읽어낼 수 없거나, 잘못된 게산 결과식, 정의할 수 없는 결과식, 문자열이 포함된 계산식(덧셈 제외)을 아우름
- 이 때 이 값을 판별하기 위해서 간단한 `isNaN` 함수를 쓰는데, 이 경우 `undefined`, `{}`, `문자열`을 true로 반환함
- 그래서 `Number.isNaN()`을 쓰는게 좋음(그러면 확실하게 구분을 함)
```js
// 느슨하게 검사(NaN이 아닌데 아래 케이스에서 true 반환)
isNaN(undefined); // true
isNaN({}); // true
isNaN('문자열'); // true

// ES2015+ (엄격하게 검사)
Number.isNaN(undefined); // false
Number.isNaN({}); // false
Number.isNaN('문자열'); // false
```

