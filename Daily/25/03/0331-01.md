## TIL

## 소프트웨어 공학

### Planning
- 프로젝트 기획은 프로젝트의 시작
- Project Plan

  - Introduction
  - Project Organization
  - Risk Analysis
  - Hardware and software resource requirements
  - Work breakdown
  - Project schedule
  - Monitoring and reporting mechanisms(Quality Plan)
 
- Software Pricing(비용)
  - 개발하는데 필요한 '비용'에 대한 정보를 고객에게 제공
  - 정확하게 예측하긴 어렵지만 그래도 대략적으로라도 알고 준비해야함
  - 개발 Resource(공수, 비용) 예측
    - 자원 : HW, SW(Licence, Source Code...)
    - 개발자의 개발 비용 : 학습 시간, 실제 개발하는데 필요한 시간 등 모든 시간 포함
  - 리소스(작업량) 표현 방법 : 맨먼스(MM), 맨데이(MD) ...
    - 예) 1MM = 한 사람의 1개월 작업량, 1MD = 한 사람의 1일 작업량
    - Working Day 기준, 하루 8시간 기준
    - 예) OO님, A라는 Feature 개발을 담당하시게 될 때, 예상되는 개발 공수 대략적으로 산정 부탁드립니다.

- Project schedule
  - 프로젝트를 진행하기 위해 여러개의 Task를 나누고, 각각의 예상 소요 시간(리소스)를 예상함
      - 이 Task들을 잘 조직화(Organize)하고, Task 사이의 의존성을 최소화하는 것이 좋음
    - 대전제 : 모든 Plan과 Estimation은 계속 변경될 수밖에 없다. 예상치 못한 이슈는 항상 발생할 수 있다.
    - 마일스톤이란?
      - 이정표
      - 프로젝트의 각 진행 단계를 특정할만한 지점(체크포인트, 시점)
        - 각 단계뼐로 산출되는 일종의 output이 있음
      - 예) 요구사항 분석 단계 - 사용자 요구사항, 설계 단계 - 아키텍처, 개발 단계 - 각 버전별 소스 코드 등
    - 스케줄 관리/표현 방식
      - 간트 차트(Gantt Chart)
        - 프로젝트 일정 관리를 위한 Bar 형태의 차트
        - 전체적인 업무 일정을 한 눈에 파악
        - 각 업무별 일정의 시작과 끝을 표현
        - 각 업무 사이의 관계 표현

### 요구사항
- 요구사항이란(Requirement)이란?
  - 시스템 개발 분야에서 어떤 과제를 수행하기 위해 필요한 조건이나 능력
  - what the system should do

- 사용자 요구사항 ----- 구체화 -----> 시스템 요구사항

- 요구사항의 종류
  - 기능 요구사항(Functional Requirement)
    - 어떤 기능이 제공되어야 하는지
    - 특정 input이 주어졌을 떄 시스템이 어떻게 동작해야 하는지(output)등 기능적인 측면을 서술하는 요구사항
    - 예) 검색 기능, 메시지 전송 기능, 마이페이지 확인 ...
  - 비기능 요구사항(Non-functional Requirement)
    - 특정한 동작이 아닌, 전체적인 시스템을 운영하기 위해 사용되는 기준을 정의한 요구사항
    - 예) 성능, 보안성, 효율성, 안정성, 응답시간, 접근성, 법 등
    - 기능 요구사항보다 명확하게 정의하기 어려움
    - 비기능 요구사항을 검증 가능하게 정의하는 것이 좋음
      - 예) 사용자들이 사용에 불편을 겪는 시간을 최소화해야 한다. -> 장애 발생 시 불편을 겪는 시간이 10분 이내여야 한다.(-> 이에 맞춰서 장애 복구 시나리오 수립)

- Requirement Engineering 프로세스
  - 요구사항 도출 -> 요구사항 분석 -> 요구사항 정의 -> 요구사항 검증(리뷰)
  - 단계가 진행될수록 점점 요구사항이 구체화되고, 명확해짐
  - 요구사항에 오류가 있는 경우가 많으므로, 검증 과정이 매우 중요함
  - 개발 도중에 나중에 오류를 발견했을 때, 요구사항을 변경하는 비용이 매우 큼
 
- 요구사항 정의서(명세서, document, requirement specification)
  - 요구사항을 서술하는 공식 문서
  - 서술 방식 : 자연어, input, output, 동작 방식, pre and post condition(사전/사후 조건), side effect, 다이어그램 등
  - 무엇을(What) 구현해야 하는지 O, 어떻게(How) 구현할건지 X
    - 완전히 분리해서 생각하기는 어렵지만, How는 아키텍처 설계에 가까운 느낌
  - 사실 최근에는 PPT 기획안, 디자인 그 자체가 요구사하이 되는 경우가 많음

### 아키텍처 설계
- 아키텍처(Architecture)란?
  - 소프트웨어 시스템의 각 하위 시스템의 관계를 표현하는 구조의 집합
  - 하나의 시스템은 여러개의 하위 시스템(sub-system, Module, Component ...)으로 구성되어 있음
  - 설계 단계의 결과물이 SW 아키텍처
 
- 과도하게 복잡한 설계는 지양해야함
- 결합도와 응집도
  - 아키텍처 설계 시 각 모듈은 응집도가 높아야 하고, 결합도는 낮아야 한다.
    - 모듈의 '독립성'을 판단하는 지표
    - why? 좋은 설계의 지표, 높은 유지보수성과 가독성 확보
  - 결합도(Coupling, 의존도) : 어떤 모듈이 다른 모듈에 의존하는 정도
  - 응집도(Cohesion) : 모듈 내부 간 연관 정도
  - 응집도를 높인다 : 하나의 모듈은 하나의 목적에만 집중하여 동작하도록 해야한다.
  - 결합도를 낮춘다 : 모듈이 서로 독립적으로 동작하도록 한다. 모듈 A의 흐름이 모듈 B의 흐름에 영향을 최대한 덜 주도록 하는 것
 
- 아키텍처 패턴 예시
  - 계층적 아키텍처
  - 클라이언트 서버 아키텍처
  - 마스터 - 슬레이브 아키텍처
  - MVC(Model, View, Controller) 아키텍처
 
### 소프트웨어 개발 프로세스 - 전통적 모델
- 소프트웨어 개발 프로세스(Software Development Process)란?
  - 소프트웨어를 만들기 위한 과정, 단계
  - 소프트웨어를 개발하기 위한 구조화된 일련의 활동(activity)
- 소프트웨어 프로세스 모델(Software Process Model)이란?
  - 소프트웨어 개발 프로세스를 추상화하여 표현한 모델
  - 가장 좋은 모델이란 없으며, 상황에 따라 적절한 프로세스 모델을 선택한다. 다양한 모델을 함께 적용할 수도 있다.
- 대표적인 Software Process Model
  - 전통적 모델
    - 폭포수 모델(Waterfall Model)
    - 나선형 모델(Spiral Model)
    - V모델
  - 현대적 모델
    - 애자일 프로세스
    - 점진적 개발
- 참고) 소프트웨어 배포 생명 주기
  - 알파 - 베타(오픈 베타, 클로즈 베타) - RC(Release Candidate) - GA(General Availability), Production, Release
 
- 전통적 모델
  - 폭포수 모델(Waterfall Model)
    - 순차적인 소프트웨어 개발 프로세스로, 각 개발 단계가 마치 폭포수처럼 아래로 향하는 듯 진행되는 모델
    - 개발 단계
      - 1) 요구사항 분석(Specification, Rquirement Eng.) : What을 정의함
        2) 설계(Planning, Design) : How를 정의함
        3) 구현(Implementation, Development)
        4) 테스트(Test, Validation)
        5) 출시 후 유지보수(Maintenance, Evolution) : 변화하는 고객의 Needs에 대응
    - 한계점
      - 순차적으로 한 단계가 완전히 완료된 후에야 그 다음 단계를 진행할 수 있음
      - 수시로 변화하는 고객의 요구사항에 대응하기 어려움
        - 현실에서 요구사항은 빈번하게 변경되며, 코드의 수정 또한 모든 단계에서 발생할 수 있음
      - 실제로 실행 불가능한 모델이라는 비판이 있음

  - 나선형 모델(Spiral Model)
    - 전체적인 프로세스가 나선 모양을 그리며, 각 단계(Phase)를 반복하면서 개발이 진행되는 모델
    - 한번 반복될 때마다 리스크(위험 요소)를 분석하고 제거하는 방식
    - 과정
      - 1) 목표 설정
        2) 위험 분석
        3) 개발
        4) 리뷰 및 다음 단계 계획
    - 장점
      - 각 단계마다 클라이언트가 프로토타입을 미리 확인할 수 있음
      - 잦은 소통과 피드백이 가능해지고, 요구사항의 변경을 수용하기보다 유연함
    - 한계점
      - 매 단계마다 목표 설정과 위험 분석이 들어가서 시간이 많이 들고 고비용이다.
      - 작고 단순한 프로젝트에는 적절하지 않을 수 있음

  - V모델
    - Verification and Validation Model
    - 폭포수 모델의 확장된 형태 중 하나
    - 각 개발 단계마다 그에 상응하는 검증을 진행하는 개발 프로세스
    - 장점
      - 각 개발 단계가 다음 단계로 이동하기 전에 테스트가 되기 때문에, 오류를 줄일 수 있다.
      - 각 단계가 상세하게 문서화가 된다.
    - 한계점
      -  폭포수 모델의 단점을 대부분 가져가며,
      -  요구사항 변경에 대응하기 어렵다.

### 소프트웨어 개발 프로세스 - 현대적 모델
- 현대적 모델
  - 애자일(Agile) 개발 프로세스
    - Agile : 재빠른, 민첩한, 기민한
    - 처음에 계획을 수립한대로 끝까지 개발하는 폭포수 모델과 반대되는 개념
    - 일정한 주기를 갖고 짧고 반복적으로 개발하여, 끊임없이 프로토타입을 만들고, 수정해가며 하나의 커다란 소프트웨어를 개발해나가는 것
    - 개발 즉시 피드백과 필요한 요구사항을 받으므로 변화에 유연하게 대처할 수 있는 문화
    - 특정 개발 방법론(모델)을 가리키는 말이라기 보다는, 기민하고 민첩하게 반복적으로 개발하는 다양한 방법론 전체를 일컫는 말
  - 참고) Incremental Development Model(점진적 개발)
    - 끝까지 완성된 버전을 한번에 전달하는 것이 아니라, 점진적으로 결과물을 만들어내고 전달
    - 우선순위가 높은 핵심 요구사항을 먼저 개발
      - 참고) MVP(Minimal Viable Product) : 최소한의 기능을 구현한 제품
    - 장점
      - 요구사항 변경에 유연함
      - 빠른 개발 가능
      - 클라이언트가 빠르고 명확하게 프로젝트의 아이디어와 실현 가능성을 확인할 수 있음
    - 한계점
      - 반복으로 인해 비용이 증가할 수 있음
     
### 코딩 컨벤션 및 네이밍 컨벤션
- Coding Convention이란?
  - 특정 프로그래밍 언어별로 궍장되는 프로그래밍 스타일이나 방법 등을 포함한 가이드라인
  - 파일(디렉토리) 구조, 들여쓰기, 주석, 선언문, 공백, 네이밍 컨벤션, 프로그래밍 원칙, Best Practice 등을 포함
  - 보통 각 조직별, 언어별로 약속해서 사용하는 Coding Convention이 있음
  - 컨벤션을 안지켰다고 문법적으로(Syntax)가 틀린 것은 아님!
  - 왜 필요한가?
    - 유지보수 비용 절감
    - 코드 가독성 증가 : 소스코드를 읽고 해석하는데 필요한 노력이 줄어듬
    - 코드 리뷰시 문법이나 네이밍룰 등 사사로운 것보다 더 중요한 것에 집중할 수 있도록 하기 위해
    - (구글 가이드라인)[https://google.github.io/styleguide/htmlcssguide.html]
   
- Naming Convention이란?
  - 소스코드에서 변수명, 함수명, 식별자명 등 '이름'을 작명하는 규칙
  - 대표적인 Naming Rule
    - camelCase : 단어 시작 대문자, 첫글자는 소문자
    - PascalCase : 모든 단어 시작 대문자. 즉, 첫글자도 대문자
    - snake_case : 단어 사이 _(언더바)
    - kebab-casing : 단어 사이 -(대시)
   
### 테스트
- Unit Test -> Integration Test -> Functional Test or System Test or E2E Test (V모델 참고)
- 단위 테스트(Unit Test)
  - 가장 작은 테스트 단위, 하나의 독립적인 모듈을 테스트함 예)class, function, component, ...
  - 각 개발자가 구현한 모듈을 직접 테스트
  - 대표적인 단위 테스트 툴 : JavaScript(Karma, Jasmine, Jest, Mocha ...), Java(JUnit), React(react-testing-library)...

- 통합 테스트(Integration Test)
  - 단위 테스트를 통과한 모듈을 대상으로 하는 테스트
  - 여러 모듈의 상호작용을 확인하기 위한 테스트(즉, 전체적으로 잘 동작하는지를 확인)
  - 단위 테스트만으로는 충분한 테스트라고 하기 어려우며, 단위 테스트가 불가능한 경우도 존재
  - 개발자 이외의 제 3자 테스터에 의한 테스트가 이루어질 수도 있음

- 참고) TDD
  - Test Driven Development, 테스트 주도 개발
    - 애자일한 개발 방법론 중 하나
  - 개발자는 요구사항을 검증하기 위한 테스트 케이스를 먼저 작성하고, 그 테스트 케이스를 통과하기 위한 코드를 이후에 개발함
  - 아래 과정을 반복
    1. 테스트 코드 작성
    2. 테스트를 통과하도록(최소한의) 코드 작성
    3. 코드 리팩토링
  - 장점 : 코드의 버그와 오류가 줄어듬, 소스 코드가 간결해짐
  - 한계점 : 테스트 코드를 작성하는 시간이 많이 들고, 초기 학습 비용이 필요함
  
