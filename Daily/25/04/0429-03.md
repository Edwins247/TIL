## TIL

### HTTPS의 개념과 보안프로토콜 이해
- HTTP: Hypertext Transfer Protocol / HTTPS: Hypertext Transfer Protocol Secure
- HTTPS는 HTTP에 SSL/TLS 보안 계층을 추가한 프로토콜, 보안 계층 추가, 데이터 보호 및 위변조 방지
- HTTP
  - 암호화: 데이터가 암호화되지 않아, 전송 중 평문으로 노출 가능
  - 데이터 무결성: 데이터 전송 중 위변조가 발생 가능, 데이터의 신뢰성이 떨어질 수 있음
  - 서버 인증: 서버의 신원을 확인할 수 없어, 가짜 웹사이트에 접속할 위험이 있음
- HTTPS
  - 암호화: SSL/TLS 프로토콜을 통해 데이터를 암호화하여, 중간에 탈취되더라도 내용을 알 수 없음
  - 데이터 무결성: 암호화와 해시 함수를 활용하여, 전송된 데이터가 변경되지 않았음을 확인할 수 있음
  - 서버 인증: 디지털 인증서를 통해 서버의 신원을 검증함으로써, 신뢰할 수 있는 통신 상대임을 보장함
- 디지털 인증서 개요
  - 브라우저 <=> 인증기관(CA)의 디지털 인증서 <=> 서버
  - 서버의 공개키: 암호화와 서명 검증에 사용
  - 소유자 정보: 인증서가 발급된 대상(도메인 이름, 조직정보 등)
  - 발급기관 정보: 인증서를 발급한 신뢰할 수 있는 기관의 정보
  - 유효기간: 인증서의 발급 및 만료 날짜
- SSL/TLS 동작 개요
  1. 인증 단계
    - 클라이언트가 서버에 접속 요청 시, 서버는 자신의 신원을 증명하기 위해 디지털 인증서를 전송, 클라이언트는 이 인증서를 검증하여, 서버가 신뢰할 수 있는 인증 기관(CA)에 의해 발급되었는지 확인 
  2. 키 교환 단계
    - 클라이언트와 서버는 비대칭키(공개키) 암호화를 활용해 임시 세션 키(대칭키)를 안전하게 교환, 이 과정을 통해 중간에 키가 노출되지 않도록 보장하며, 이후의 데이터 통신에 사용할 암호화 키 설정
  3. 세션 암호화 단계
    - 교환된 세션 키를 사용하여, 실제 데이터 전송 시 대칭키 암호화를 적용, 이 단계에서는 데이터의 기밀성과 무결성이 유지되며, 빠르고 효율적인 암호화 통신이 이루어짐

#### SSL/TLS 보안 프로토콜
- SSL(Secure Socket Layer) -> TLS(Transport Layer Security)
  - 보안성 강화: SSL보다 강력한 암호화 알고리즘과 보안 프로토콜 구조 제공
  - 핸드셰이크 개선: 암호 스위트 협상, 인증, 키 교환과정 개선
  - 현대적 보안 표준: 현재 웹 보안에서는 SSL 대신 TLS가 사용되며, SSL은 폐기 및 비권장
- 암호화(Encryption): 평문(원본 데이터)을 읽을 수 없는 형태인 암호문으로 변환하는 과정
- 복호화(Decryption): 암호문을 원래의 평문으로 되돌리는 과정
- Hash 해시함수: 복호화가 불가능한 알고리즘
  - 임의 길이의 데이터를 고정 길이의 해시 값으로 변환하는 단방향 함수
  - 해시 값으로부터 원래 데이터를 복원할 수 없으며, 데이터 무결성 검증이나 비밀번호 저장 등에 사용
  - SHA-256, SHA-1, MD5등이 있고, SSL/TLS에서는 CA 전자서명, Finger Print에 사용
- 대칭키
  - 키가 1개인 암호화 기법, 암호화에 사용되는 키와 복호화에 사용되는 키가 동일함
  - 암호화, 복호화 속도가 빠름 / 키가 유출되면 보안 위험
- 공개키(비대칭키)
  - 공개키와 개인키(private key) 2개의 키를 사용하는 암호화 방식
  - 암호화, 복호화 속도가 느림 / 개인키만 안전하게 보관한다면 공개키는 자유롭게 배포 가능
- 공개키를 사용한 클라이언트-서버 통신?
  - 서버의 공개키를 클라이언트에게 배포하고, 클라이언트가 서버에 데이터를 전송할 때마다 공개키로 암호화하고, 서버는 개인키로 복호화
  - 공개키 방식만을 사용하면 성능 이슈가 있어서 SSL/TLS는 공개키와 대칭키를 혼합하여 사용
- SSL/TLS 동작 과정
  - 1. 핸드셰이크 -> 2. 세션 -> 3. 세션 종료
- SSL/TLS 핸드셰이크
  - 클라이언트와 서버가 안전한 통신을 위한 암호화된 연결(세션)을 설정하는 초기 협상 과정
- SSL/TLS 핸드셰이크 목적
  - 서버(및 선택적 클라이언트)인증: 디지털 인증서를 통해 상대방의 신원 확인
  - 세션 키 교환: 공개키 암호화를 사용하여 임시 대칭키(세션키)를 안전하게 교환
  - 보안 채널 설정: 교환된 세션 키를 기반으로 데이터 암호화와 무결성 검증을 수행
- SSL/TLS 핸드 셰이크: 1. Client Hello
  - 클라이언트가 서버에 접속하는 과정
  - 클라이언트 측에서 생성한 랜덤데이터, 클라이언트가 지원하는 암호화 방식들, 클라이언트의 브라우저 정보, TLS 버전 등을 서버에 전달
- SSL/TLS 핸드 셰이크: 2. Server Hello
  - Client Hello에 서버가 응답하는 과정
- SSL/TLS 핸드 셰이크: 3. 인증서 검증
  - 브라우저는 인증서를 발급한 CA가 내장한 CA 리스트에 포함되어 있는지 확인함
  - 포함되어 있으면 해당 CA의 공개키를 이용해서 인증서를 복호화함
  - 전자서명을 통해 누가 메시지를 썼는지 알려주고, 메시지가 위조되지 않았음을 증명함
- SSL/TLS 핸드 셰이크: 4. Pre Master Secret 생성 및 전달
  - 서버 측에서 생성한 랜덤 데이터와 클라이언트 측에서 생성한 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성함
  - 공개키 방식으로 pre master secret을 서버에 전달
- SSL/TLS 핸드 셰이크: 5. 핸드셰이크 종료
  - 서버는 클라이언트가 전송한 pre master secret값을 자신의 비공개키로 복호화
  - pre master secret 값을 master secret 값으로 공정. master secret으로 session key를 생성
- SSL/TLS 세션
  - 서버와 클라이언트가 데이터를 주고 받는 단계, 데이터를 서로 공유하고 있는 대칭키 방식으로 생성한 세션키로 암호화하고 복호화함
  - SSL/TLS 세션 종료: 사이트에 대한 접속이 종료되었을 때, 세션이 종료되었음을 확인하는 단계

#### 인증기관(CA)과 신뢰체계
- 인증기관 Certificate Authority(CA)
  - 디지털 인증서를 발급하고 관리하는 신뢰할 수 있는 제3자 기관
  - 사용자 및 서버의 신원 검증
  - 인증서 발급, 갱신, 폐지 관리
- Self-Signed 인증
  - 인증서의 서명이 외부 CA가 아닌, 인증서를 발급한 주체(소유자)에 의해 이루어짐
  - 외부 신뢰기관의 검증 없이 자체적으로 서명되어, 공식 신뢰 체계에 포함되지 않음
  - 테스트, 개발, 내부 네트워크 등 실서비스가 아닌 환경에서 주로 사용
  - 브라우저나 운영체제에서 신뢰되지 않아 경고 메시지가 표시됨
  - 외부 사용자가 접근하는 서비스는 CA에서 발급한 인증서로 교체 필요
- 인증서 발급 과정
  - 인증기관 Certificate Authority(CA)
    - 인증서를 발급받고자 하는 기관은 사이트 정보(도메인등)와 공개키를 CA에 제출
    - CA는 검증 후 기관의 공개키를 해시함. 이를 FingerPrint 지문이라고 함
    - FingerPrint를 CA의 비밀키로 암호화하여 인증서에 포함함. 이를 Digital Signing 디지털 서명이라 함
  - 인증서 체인
    - 최종 사용자(또는 서버) 인증서에서 시작해 중간 CA를 거쳐, 최종적으로 신뢰할 수 있는 루트 CA까지 이어지는 신뢰의 경로
    - 최종 인증서의 신뢰성을 보장하기 위해, 각 단계의 인증서가 상위 CA에 의해 서명된 사실을 확인
- 인증서 발급
  - 디지털 인증서 SSL 인증서라고도 불림
  - 인증서를 발급한 CA, 서비스의 도메인, 서버측 공개키, 지문 Finger Print, 디지털 서명 등 포함

 ##### 관련 면접 질문
 1. HTTP와 HTTPS의 주요 차이점은 무엇인가요?
 2. TLS 핸드쉐이크 과정은 어떻게 진행되는가?
 3. 대칭키 암호화와 비대칭키 암호화의 차이에 대해 설명하세요.

-----

### Load Balancer 기본원리와 구성
- 로드밸런서란 무엇인가?
  - 트래픽 분산: 요청을 여러 서버로 나눔
  - 부하 분산: 서버 간 작업량을 균등하게 유지함
  - 서버 상태 모니터링: 서버의 상태를 확인해 장애를 감지함(Health Check)
- 로드밸런싱의 필요성
  - 서버 과부화 문제
    - 하나의 서버가 모든 요청을 처리하면 성능이 저하됨
    - 사용자가 많아질수록 응답 속도가 느려지고 장애 위험이 커짐(ex. 쇼핑몰 사이트에서 트래픽이 급증하면 서버가 다운될 가능성이 높아짐)
  - 고가용성 보장
    - 다수의 서버를 운영하여 장애 시에도 서비스가 지속됨
    - 특정 서버가 다운되면 트래픽을 다른 서버로 분산해 대응함(ex. 클라우드 환경에서 로드밸런서를 활용하면 서버 장애에도 서비스가 끊기지 않음)
  - 성능 향상
    - 여러 서버가 트래픽을 분산처리하여 응답 속도를 높임
    - 자원을 효율적으로 활용해 사용자 경험을 개선함(ex. 대규모 게임 서버에서 부하를 분산하면 쾌적한 플레이 환경을 제공함)
  - 확장성 제공
    - 서버를 추가하여 시스템을 손쉽게 확장할 수 있음
    - 클라우드 환경에서는 트래픽에 따라 서버를 동적으로 추가/제거 가능함(ex. Auto Scaling, Scale Out <-> Scale Up)

#### L4/L7 로드밸런서
- OSI 7계층: 네트워크 통신은 7단계로 구성됨
- L4(전송 계층)는 데이터 전송을, L7(응용 계층)는 애플리케이션 데이터를 다룸
- 로드밸런서는 이 계층에 따라 동작 방식이 달라짐
- L4 로드밸런서
  - IP 주소와 포트(TCP/UDP) 정보를 기반으로 트래픽을 분산함
  - 클라이언트에서 로드밸런서(DNS)로 요청을 보냈을 때 최적의 서버로 요청을 전송함
- L7 로드밸런서
  - HTTP/HTTPS와 같은 애플리케이션 데이터를 분석해 트래픽을 분산함
  - 트래픽 분산 뿐만 아닌 URL 기반 라우팅, HTTP 헤더 분석, SSL/TLS 암호화 해제 등의 추가기능을 함
- L4/L7 로드밸런서 비교
  - L4
    - 작동계층: 전송계층(Layer 4)
    - 주요 프로토콜: TCP, UDP
    - 분산 기준: IP 주소, 포트 -> 네트워크 수준 분산
    - 처리 속도: 상대적으로 빠름
    - 기능 및 유연성: 상대적으로 제한적
  - L7
    - 작동계층: 어플리케이션 계층(Layer 7)
    - 주요 프로토콜: HTTP, HTTPS
    - 분산 기준: 요청내용(URL, 헤더, 쿠키 등) -> 컨텐츠 기반 분산
    - 처리 속도: 상대적으로 느림
    - 기능 및 유연성: 다양한 기능 및 유연성
- SSL Offloading
  - 로드밸런서가 암호화된 HTTPS 트래픽을 해제해 백엔드 서버로 전달
  - 백엔드 서버의 암호화 부하를 줄임, 클라이언트-로드밸런서, 백엔드 간 내부 네트워크 암호화 필요
 
#### 트래픽 분산 알고리즘
- 트래픽 분산: 효율성과 안정성
  - 서버 간 부하를 균등하게 분배해 성능을 최적화함
  - 장애를 방지하고 응답 속도를 높이는 것이 핵심임
  - 효율적인 자원 활용으로 서비스 품질이 향상됨
- 라운드로빈(Round Robin)
  - 트래픽을 순서대로 각 서버에 분배함
  - 구현이 간단하고 공평하지만, 서버 성능 차이를 고려하지 않는다는 한계
- 가중치 라운드로빈(Weighted Round-Robin)
  - 서버 성능에 따라 가중치를 부여해 트래픽을 분배함
  - 성능이 높은 서버에 더 많은 요청을 할당해 효율적임
- 최소 연결 수(Least Connections)
  - 현재 연결 수가 가장 적은 서버로 요청을 전송함
  - 실시간 부하를 반영해 효율적이지만, 계산 리소스가 필요함
- 최단 응답 시간(Fastest)
  - 서버의 응답 시간을 측정하여 가장 빠른 응답을 보인 서버에 요청을 전달함
  - 빠른 응답 속도와 안정적인 서비스 제공에 유용함
- IP 해시(IP Hashing)
  - 클라이언트 IP를 기반으로 특정 서버에 트래픽을 고정함
  - 세션 지속성을 유지해 상태 정보가 필요한 경우 유리

##### 관련 면접 질문
1. 로드밸런싱이 시스템에 왜 필요한지 설명하고, 구체적인 예를 들어주세요.
2. L4와 L7 로드밸런서의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적합한가요?
3. 라운드 로빈과 가중치 라운드 로빈 알고리즘의 차이점을 설명해보세요.
