## TIL

### 렌더링 최적화
- 컴포넌트는 자신의 state가 변경되거나, 부모에게서 받는 props가 변경되었을 때마다 다시 렌더링 됨
- 심지어 자식 컴포넌트에서 렌더링 최적화를 위한 별도의 코드를 추가하지 않으면, 부모에게서 받는 props가 변경되지 않았더라도 다시 리렌더링 됨
- 함수 컴포넌트는 그냥 함수임, jsx를 반환할 뿐임 그리고 함수 컴포넌트가 렌더링 된다는 것은 누군가(부모 컴포넌트)가 그 함수를 호출하여 실행되는 것임
- 함수가 실행될 때마다 내부에 선언되어 있던 표현식(변수 등)들도 매번 다시 계산됨
- useMemo & useCallback 리액트 훅을 사용할 수 있음
- 이 때 useMemo를 아래와 같이 쓴다면 해당 하는 color, movie 선택자가 선택되서 처리될 때만 해당 함수만을 불러서 처리함.
- 고비용 계산을 함수에만 useMemo를 쓰라고 공식문서상에서 권장을 함. 메모이제이션 처리를 하는 것임
```jsx
import React, { useMemo } from "react";
import "./styles.css";

const getColorKor = (color) => {
  console.log("getColorKor");
  switch (color) {
    case "red":
      return "빨강";
    case "orange":
      return "주황";
    case "yellow":
      return "노랑";
    case "green":
      return "초록";
    case "blue":
      return "파랑";
    case "navy":
      return "남";
    case "purple":
      return "보라";
    default:
      return "레인보우";
  }
};

const getMovieGenreKor = (movie) => {
  console.log("getMovieGenreKor");
  switch (movie) {
    case "Marriage Story":
      return "드라마";
    case "The Fast And The Furious":
      return "액션";
    case "Avengers":
      return "슈퍼히어로";
    default:
      return "아직 잘 모름";
  }
};

const Info = ({ color, movie }) => {
  const colorKor = useMemo(() => getColorKor(color), [color]);
  const movieGenreKor = useMemo(() => getMovieGenreKor(movie), [movie]);

  return (
    <div className="info-wrapper">
      제가 가장 좋아하는 색은 {colorKor} 이고, <br />
      즐겨보는 영화 장르는 {movieGenreKor} 입니다.
    </div>
  );
};

export default Info;
```
- useCallback의 경우 useMemo와 비슷하게 메모이제이션을을 통해서 콜백의 의존성이 변경되었을 때, 불필요한 렌더링을 방지하기 위해서 처리함
- 이러면 state 변경될 때, 아래의 적용된 onChangeHandler를 만들어서 처리하지 않고 렌더링도 하지 않는다는 것임
- [공식문서](https://ko.legacy.reactjs.org/docs/hooks-reference.html#usecallback)
```jsx
import React, { useState, useCallback } from "react";
import Info from "./Info";
import "./styles.css";

const App = () => {
  const [color, setColor] = useState("");
  const [movie, setMovie] = useState("");

  const onChangeHandler = useCallback((e) => {
    if (e.target.id === "color") setColor(e.target.value);
    else setMovie(e.target.value);
  }, []);

  return (
    <div className="App">
      <div>
        <label>
          What is your favorite color of rainbow ?
          <input id="color" value={color} onChange={onChangeHandler} />
        </label>
      </div>
      <div>
        What is your favorite movie among these ?
        <label>
          <input
            type="radio"
            name="movie"
            value="Marriage Story"
            onChange={onChangeHandler}
          />
          Marriage Story
        </label>
        <label>
          <input
            type="radio"
            name="movie"
            value="The Fast And The Furious"
            onChange={onChangeHandler}
          />
          The Fast And The Furious
        </label>
        <label>
          <input
            type="radio"
            name="movie"
            value="Avengers"
            onChange={onChangeHandler}
          />
          Avengers
        </label>
      </div>
      <Info color={color} movie={movie} />
    </div>
  );
};

export default App;
```
- [공식문서](https://ko.legacy.reactjs.org/docs/react-api.html#reactmemo)
- 렌더링 최적화는 또 다른 방법이 있음, useMemo와 useCallback은 컴포넌트 내에서 값과 함수를 메모이제이션 하지만 React.memo는 컴포넌트 자체를 메모이제이션 처리하는 것임
- 아래와 같이 사용할 수 있음, 이러면 이전의 렌더링 한 것을 메모이제이션해서 리렌더링 없이 활용함
```jsx
import "./styles.css";
import React, { useState } from "react";

export default function Parent() {
  const [number, setNumber] = useState(1);
  const age = 1;

  return (
    <div className="App">
      <button
        onClick={() => {
          setNumber(number + 1);
        }}
      >
        Click
      </button>
      <Child age={age} />
    </div>
  );
}

const Child = React.memo((props) => {
  console.log("Child component");
  console.log(props.age);
  return <div>Child</div>;
});
```

### Code Splitting
- [공식문서](https://ko.legacy.reactjs.org/docs/code-splitting.html#gatsby-focus-wrapper)
- 코드 분할을 위해 Dynamic import, React.lazy() 사용함
- Webpack은 import 구문을 만나면 앱의 코드를 분할함, 아래와 같이 사용한다면 실제 실행 후 검사를 하면 static/js에 별도로 분할된 파일로써 함수가 포함됨
```jsx
// math.js
export default function add(a, b) {
    return a + b;
}
```
```jsx
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient, useQueries } from "react-query";
import { getPosts, getUser, updateNickname } from "../mocks/api";

// // 정적으로 사용
// import add from "./math";
// add(1, 2)

import ("./math").then(math => console.log(math.add(1, 2)))

// api를 통해 현재 닉네임값 가져오기
// handleSubmit: 업데이트 된 inputValue를 서버에 전송해서, 닉네임값 업데이트하기

export default function Edit() {
  const [inputValue, setInputValue] = useState("");
  const queryClient = useQueryClient();
```
- 이처럼 코드 분할이 가능한데, 이때 컴포넌트 자체를 dynamic import를 위와 같이 할 수 있음, 이러한 경우에는 React.lazy 함수를 통해서 동적 import를 사용해 컴포넌트를 렌더링 할 수 있음
```jsx
import React from "react"

export default function Post(props) {
    return (
        <li>
            {props.title}
        </li>
    )
}
```
```jsx
import React, { useState, lazy, Suspense } from "react";
import { useQuery, useMutation, useQueryClient, useQueries } from "react-query";
import { getPosts, getUser, updateNickname } from "../mocks/api";

const Post = lazy(() => import("./Post"));

// // 정적으로 사용
// import add from "./math";
// add(1, 2)

// import ("./math").then(math => console.log(math.add(1, 2)))

// api를 통해 현재 닉네임값 가져오기
// handleSubmit: 업데이트 된 inputValue를 서버에 전송해서, 닉네임값 업데이트하기

export default function Edit() {
  const [inputValue, setInputValue] = useState("");
  const queryClient = useQueryClient();

  // const { data : user } = useQuery('@getUser', getUser, {
  //   staleTime: Infinity
  // });

  // const { data : posts } = useQuery('@getPosts', getPosts, {
  //   staleTime: Infinity
  // });

  const results = useQueries([
    {
      queryKey: ['@getUser'],
      queryFn: getUser,
      staleTime: Infinity
    },
    {
      queryKey: ['@getPosts'],
      queryFn: getPosts,
      staleTime: Infinity
    },
  ]);

  const user = results[0].data;
  const posts = results[1].data;

  const mutation = useMutation(updateNickname, {
    onSuccess: () => {
      queryClient.invalidateQueries('@getUser');
    }
  });

  const handleChange = (e) => {
    setInputValue(e.target.value);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    mutation.mutate(inputValue);
  };

  // if (isLoading) return <span>Loading...</span>

  return (
    <>
      <h1>Edit</h1>
      <h3>현재 닉네임: {user?.nickName}</h3>
      <form onSubmit={handleSubmit}>
        <label>
          변경할 닉네임:
          <input type="text" value={inputValue} onChange={handleChange} />
        </label>
      </form>
      <ul>
        {posts.map((post) => (
          <Post title={post.title}/>
        ))}
      </ul>
    </>
  );
}
```
- 위와 같이 한다면 앞서 했던 실습처럼 별도의 static/js 파일에 분할된 컴포넌트로 처리가 됨
