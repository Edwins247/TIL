## TIL

### 비동기 통신과 전역 상태 관리의 최신 흐름
- 프로젝트의 크기가 커질수록 API 호출 후 전역 상태를 업데이트 해줘야 하는 상황마다 작성해야 하는 코드가 많음, store 크기도 비대해짐
- API 호출 후 응답 데이터는 Server State로 UI 개발을 위한 데이터는 Client State로 처리하는 등 이럴 때 React Query를 많이 사용함
- React Query의 경우, 서버 state를 fecth, caching, synchronizing, updating을 함

### React Query
- 먼저 Query를 사용해서 비동기 처리를 해 볼 것임
- useQuery의 경우 유니크한 key와 두번째 인자로 함수가 들어가는데 Promise를 리턴함, refecthing, caching, query를 여러곳에서 쓸 수 있음
- loading, error, success 등의 상태를 가지고 있고 처리할 수 있음
- 먼저 아래와 같이 최상위 컴포넌트의 객체를 설정하고 처리해야함
```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import Edit from "./pages/Edit";
import { QueryClientProvider, QueryClient } from "react-query";

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/edit" element={<Edit />} />
        </Routes>
      </BrowserRouter>
    </QueryClientProvider>
  );
}

export default App;=
```
- 그리고 아래와 같이 useQuery를 쓸 수 있음
```jsx
import React, { useState } from "react";
import { useQuery } from "react-query";
import { getUser } from "../mocks/api";

// api를 통해 현재 닉네임값 가져오기
// handleSubmit: 업데이트 된 inputValue를 서버에 전송해서, 닉네임값 업데이트

export default function Edit() {
  const [inputValue, setInputValue] = useState("");

  const { data, isLoading } = useQuery('@getUser', getUser)

  const handleChange = (e) => {
    setInputValue(e.target.value);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
  };

  if (isLoading) return <span>Loading...</span>

  return (
    <>
      <h1>Edit</h1>
      <h3>현재 닉네임: {data.nickName}</h3>
      <form onSubmit={handleSubmit}>
        <label>
          변경할 닉네임:
          <input type="text" value={inputValue} onChange={handleChange} />
        </label>
      </form>
    </>
  );
}
```
- 그리고 Mutations의 경우, 데이터를 create, update, delete를 하거나 service side-effect를 처리할 때 주로 씀
- mutation 기반으로 요청을 하고 isLoading, isError, isSuccess 처리를 하고, mutate 처리를 해서 데이터를 핸들링 할 수 있음
- 그리고 query invalidation을 통해서, query를 refetch해서 데이터에 대해서 invalidate를 할 수 있음, 데이터를 의도적으로 업데이트해서 UI나 데이터를 fetch해서 리렌더링 할 수 있음(바로 업데이트 가능)
- 아래와 같이 활용함(그렇게 하지 않으면 redux-thunk나 전역 상태를 직접 처리해서 관리해야했을 것임)
```jsx
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "react-query";
import { getUser, updateNickname } from "../mocks/api";

// api를 통해 현재 닉네임값 가져오기
// handleSubmit: 업데이트 된 inputValue를 서버에 전송해서, 닉네임값 업데이트하기

export default function Edit() {
  const [inputValue, setInputValue] = useState("");
  const queryClient = useQueryClient();
  const { data, isLoading } = useQuery('@getUser', getUser);
  const mutation = useMutation(updateNickname, {
    onSuccess: () => {
      queryClient.invalidateQueries('@getUser');
    }
  })

  const handleChange = (e) => {
    setInputValue(e.target.value);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    mutation.mutate(inputValue);
  };

  if (isLoading) return <span>Loading...</span>

  return (
    <>
      <h1>Edit</h1>
      <h3>현재 닉네임: {data.nickName}</h3>
      <form onSubmit={handleSubmit}>
        <label>
          변경할 닉네임:
          <input type="text" value={inputValue} onChange={handleChange} />
        </label>
      </form>
    </>
  );
}
```
- React Query는 cache의 역할을 할 수 있음, 다시 fetch 할 것 없이 cache를 통해서 데이터를 캐싱해서 다시 데이터를 사용할 수 있게 해주는 것임
- 기본적으로 캐싱으로 정해진 옵션들이 있는데, 이를 커스텀하기 위해서 staleTime, cacheTime 값을 수정해서 처리할 수 있음
- 기본값으로는 캐싱은 하지만 staleTime 값에 의해서 계속 refetch하는 상태임
- 하지만 한 번 값으로 불러와서 처리가 끝났다면 사실 굳이 해당 데이터를 쓸 페이지에서 refetch를 할 필요가 없을 것임
- 그래서 이런식으로 refetch하는 것을 아래와 같이 방지할 수 있음
```jsx
import React from "react";
import { useNavigate } from "react-router-dom";
import { useQuery } from "react-query";
import { getUser } from "../mocks/api";

export default function Home() {
  const navigate = useNavigate();
  const { data, isLoading } = useQuery('@getUser', getUser, {
    staleTime: Infinity
  })

  return (
    <div>
      <h1>Hello, {data?.nickName}</h1>
      <button onClick={() => navigate("/edit")}>Go Edit Page</button>
    </div>
  );
}
```
```jsx
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "react-query";
import { getUser, updateNickname } from "../mocks/api";

// api를 통해 현재 닉네임값 가져오기
// handleSubmit: 업데이트 된 inputValue를 서버에 전송해서, 닉네임값 업데이트하기

export default function Edit() {
  const [inputValue, setInputValue] = useState("");
  const queryClient = useQueryClient();
  const { data, isLoading } = useQuery('@getUser', getUser, {
    staleTime: Infinity
  });
  const mutation = useMutation(updateNickname, {
    onSuccess: () => {
      queryClient.invalidateQueries('@getUser');
    }
  })

  const handleChange = (e) => {
    setInputValue(e.target.value);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    mutation.mutate(inputValue);
  };

  if (isLoading) return <span>Loading...</span>

  return (
    <>
      <h1>Edit</h1>
      <h3>현재 닉네임: {data.nickName}</h3>
      <form onSubmit={handleSubmit}>
        <label>
          변경할 닉네임:
          <input type="text" value={inputValue} onChange={handleChange} />
        </label>
      </form>
    </>
  );
}
```
- 아니면 개별적으로 주지않고 혹은 최상위 컴포넌트에서 값을 처리해서 중복을 방지할 수 있음
- cacheTime의 경우, 캐시가 되어 있는지 여부를 기반으로 staleTime을 보고 그 데이터를 fetch하는지 결정됨, cacheTime을 설정하는 이유는 매번 캐싱을 할 수 없기 때문에 unmount되고 나서 지우는 것을 나타내는 것임
- unmount되고 기본값으로 5분 정도로 캐싱이 유지되어 처리됨

### Suspense
- [공식문서](https://ko.react.dev/reference/react/Suspense)
- React 18에서의 Suspense라는 기능이 추가됨
- 이 Suspense 컴포넌트의 경우, 데이터를 가져오는 동안 기다릴 수 있게 해주는 새로운 기능임
- 데이터 로딩의 초점을 맞췄지만, 이미지, 스크립트, 그 밖의 비동기 작업을 기다리는데에도 사용됨
- 렌더링 직후 불러오기나 불러오기 이후 렌더링이나 혹은 불러올 때의 렌더링, 그런 상황에서 잘 활용할 수 있음
- Suspense를 사용하면, 렌더링을 시작하기 전에 응답이 오기를 기다리지 않아도 됨, 이에 대해서 if 조건문으로 로딩 여부를 확인하거나 별도로 처리할 필요가 없는 것
- 이 때 react-query와 함께 쓸 수 있음
- [react query & suspense](https://tanstack.com/query/v4/docs/framework/react/guides/suspense)
- Query Client 생성시, suspense 옵션을 활용해서 처리할 수 있음, 에러 처리도 같이 할 수 있는 등 유용함(fallback으로 어떤 것을 렌더링 할 지)
- 아래와 같이 처리해서 활용할 수 있음
```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import Edit from "./pages/Edit";
import { QueryClientProvider, QueryClient } from "react-query";
import { Suspense } from "react";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<span>Loading...</span>}>
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/edit" element={<Edit />} />
          </Routes>
        </BrowserRouter>
      </Suspense>
    </QueryClientProvider>
  );
}

export default App;
```
```jsx
import React from "react";
import { useNavigate } from "react-router-dom";
import { useQuery } from "react-query";
import { getUser } from "../mocks/api";

export default function Home() {
  const navigate = useNavigate();
  const { data, isLoading } = useQuery('@getUser', getUser, {
    staleTime: Infinity,
    suspense: true,
  })

  // if (isLoading) return <span>Loading...</span>

  return (
    <div>
      <h1>Hello, {data?.nickName}</h1>
      <button onClick={() => navigate("/edit")}>Go Edit Page</button>
    </div>
  );
}
```
- 이 때 추가로 병렬적으로 API 호출을 해서 하려면 아래와 같이 useQueries를 써야하고, Suspense를 활용해 볼 수 있음
```jsx
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient, useQueries } from "react-query";
import { getPosts, getUser, updateNickname } from "../mocks/api";

// api를 통해 현재 닉네임값 가져오기
// handleSubmit: 업데이트 된 inputValue를 서버에 전송해서, 닉네임값 업데이트하기

export default function Edit() {
  const [inputValue, setInputValue] = useState("");
  const queryClient = useQueryClient();

  // const { data : user } = useQuery('@getUser', getUser, {
  //   staleTime: Infinity
  // });

  // const { data : posts } = useQuery('@getPosts', getPosts, {
  //   staleTime: Infinity
  // });

  const results = useQueries([
    {
      queryKey: ['@getUser'],
      queryFn: getUser,
      staleTime: Infinity
    },
    {
      queryKey: ['@getPosts'],
      queryFn: getPosts,
      staleTime: Infinity
    },
  ]);

  const user = results[0].data;
  const posts = results[1].data;

  const mutation = useMutation(updateNickname, {
    onSuccess: () => {
      queryClient.invalidateQueries('@getUser');
    }
  });

  const handleChange = (e) => {
    setInputValue(e.target.value);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    mutation.mutate(inputValue);
  };

  // if (isLoading) return <span>Loading...</span>

  return (
    <>
      <h1>Edit</h1>
      <h3>현재 닉네임: {user?.nickName}</h3>
      <form onSubmit={handleSubmit}>
        <label>
          변경할 닉네임:
          <input type="text" value={inputValue} onChange={handleChange} />
        </label>
      </form>
      <ul>
        {posts.map((post) => (
          <li>{post?.title}</li>
        ))}
      </ul>
    </>
  );
}
```
