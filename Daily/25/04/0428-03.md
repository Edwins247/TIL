## TIL

### RAM이란?
- RAM(Random Access Memory), 컴퓨터의 작업 공간, 컴퓨터가 프로그램을 실행할 때, 데이터를 빠르게 읽고 쓰는 역할을 함
- RAM 특징
  - 휘발성(volatile): 전원이 꺼지면 데이터가 사라짐
  - 전원이 꺼져도 데이터가 사라지지 않는 저장 장치는 비휘발성 저장 장치 = HDD, SSD등
  - 빠른 속도: HDD/SDD보다 훨씬 빠름
  - CPU와 직접 연결: CPU가 연산할 데이터를 임시 저장
  - 멀티 태스킹에 영향: 여러 프로그램을 동시에 실행할 때 중요
- RAM이 필요한 이유
  - CPU가 직접 데이터를 저장할 공간이 부족해서(CPU에는 아주 작은 캐시만 있기 때문에, 더 큰 작업 공간이 필요함)
  - HDD/SSD는 너무 느려서(데이터를 직접 하드디스크에 불러오면 속도가 느리므로, RAM을 중간 저장소로 사용)
- RAM이 많으면
  - 프로그램 실행 속도가 빨라짐
  - 여러 개의 프로그램을 동시에 실행해도 원활함
  - 게임, 영상 편집 등 메모리 많이 쓰는 작업이 원활함

#### RAM의 종류
- RAM은 여러 유형이 있으며 용도와 기술 발전에 따라 다양한 분류로 나뉨
- SRAM, Static RAM, 정적 RAM
  - 속도가 매우 빠름, 전력 소비는 적음
  - flip-flop 기반의 구조, 비싼 가격, CPU 캐시 메모리(L1, L2, L3) 용도
  - 전원이 켜져 있는 동안 데이터를 유지하며, 매우 빠르지만 고가
- DRAM, Dynamic RAM, 동적 RAM
  - 속도가 비교적 느림, 전력 소비가 많음
  - capacitor 기반 구조, 저렴한 가격, 일반적인 시스템 메모리(RAM)
  - 지속적으로 새로 고침(refresh)이 필요하며, 대용량 저장에 적합함, 우리가 일반적으로 말하는 RAM은 대부분 DRAM임
- DRAM의 종류
  - SDRAM(Synchronous DRAM)
    - CPU 클럭(Clock)과 동기화(Synchronous)되어 데이터를 읽고 쓰는 RAM
    - 현재 대부분의 RAM은 SDRAM 기반, SDRAM 이전에는 FPM DRAM(Fast Page Mode DRAM), EDO DRAM(Extended Data Out DRAM)이 있음
  - DDR SDRAM(Double Data Rate SDRAM)
    - 한 번의 클럭(Clock) 주기에서 데이터를 두 번 전송하는 방식의 SDRAM
    - DDR1: 구형(2000년대 초반) / DDR2: 속도 향상, 전력 절감 / DDR3: 일반적인 DDR 메모리
    - DDR4: 현재 일반적으로 사용 / DDR5: 최신 규격, 더 높은 속도와 전력 효율
  - LPDDR(Low Power DDR)
    - 저전력 모바일용 DDR 메모리, 스마트폰, 태블릿, 노트북 등 전력 소비가 중요한 기기에서 사용됨
    - LPDDR3: 구형 스마트폰, 태블릿
    - LPDDR4: 최신 스마트폰, 노트북
    - LPDDR5: 최신 프리미엄 모바일 기기
  - GDDR(Graphic DDR)
    - 그래픽 카드(GPU) 전용 RAM. GPU 연산 속도에 최적화된 메모리, 높은 대역폭을 제공
    - GDDR3: 구형 GPU
    - GDDR5: 보급형 GPU
    - GDDR6: 최신 고성능 GPU

#### 메모리의 주소 공간
- 컴퓨터에서 프로그램이 실행되려면 메모리(RAM)에 로드되어야 함
- CPU와 운영체제(OS)는 메모리를 다루는 방식이 다름, 이 때, 메모리 주소 공간의 논리 주소(Logical Address)와 물리 주소(Physical Address) 개념이 등장함
- 메모리 주소 공간(Memory Address Space)은 컴퓨터가 메모리를 참조할 수 있는 범위(주소 영역), 메모리는 주소로 나뉘어 있으며, 각 메모리 위치에는 고유한 번호(주소)가 부여됨
- 물리 주소와 논리 주소
  - 컴퓨터에서 메모리에 저장된 데이터의 위치는 주소로 표현됨
  - 이 주소는 2가지 종류가 있음, 물리 주소와 논리 주소
  - 물리 주소는 실제 메모리 하드웨어가 데이터를 저장하는 위치를 나타냄
  - 논리 주소는 CPU의 실행 중인 프로그램이 사용하는 주소
- 물리 주소(Physical Address)
  - RAM(메모리)칩에서 데이터가 저장된 실제 위치
  - 운영체제(OS)와 CPU가 직접 접근하는 주소
  - 컴퓨터 하드웨어(메모리 컨트롤러, CPU, 버스)가 사용하는 주소
  - RAM의 물리적인 칸에 해당하는 주소값
  - 하드웨어적으로 결정되며 변경되지 않음
  - ex) RAM에 저장된 데이터가 0x3F2A1000 위치에 있다면, 이 주소가 물리 주소이며, 운영체제가 직접 관리
- 논리 주소(Logical Address)
  - 프로그램이 실행될 때, CPU가 바라보는 가상의 주소
  - CPU가 실행 중인 프로그램에서 사용하는 주소
  - 프로그램마다 독립적인 주소 공간을 가짐, 실제로 RAM에 저장된 위치(물리 주소)오 다를 수 있음
  - 운영체제(OS)가 논리 주소를 물리 주소로 변환하여 메모리 접근
- CPU는 논리 주소를 기반으로 동작함, CPU와 메모리가 상호작용을 하려면 논리 주소와 물리 주소 간 변환 작업이 필요함
- 논리 주소 -> 물리 주소 변환 과정
  - CPU는 직접 물리 주소를 사용하지 않고, 논리 주소를 기반으로 연산함
  - 이후 운영체제(OS)와 메모리 관리 장치(MMU, Memory Management Unit)가 논리 주소를 물리 주소로 변환하여 메모리에 접근함
  - 변환 과정
    1. 프로그램 실행 -> CPU가 논리 주소 생성
    2. 운영체제가 논리 주소를 관리
    3. MMU가 논리 주소 -> 물리 주소로 변환
    4. RAM에서 변환된 물리 주소를 통해 데이터 읽기/쓰기

#### MMU가 변환되는 과정
- MMU = 프로그램이 실행될 때, 논리 주소를 통해 RAM에 접근할 수 있음
- 베이스 레지스터(Base Register)를 활용하여 변환
- 베이스 레지스터는 논리 주소를 변환할 때 기준이 되는 레지스터
- 논리 주소는 "상대적인 주소", 베이스 레지스터는 실제 메모리에서 프로세스가 시작하는 "기준점"
- 예시1. 단순한 베이스 레지스터 변환 방식
  - 베이스 레지스터 값 = 500, 프로그램이 논리 주소 100을 참조
  - 실제 물리 주소 = 베이스 레지스터 + 논리 주소 = 5000 + 100 = 5100
  - 논리 주소 100은 물리 주소 5100으로 변환되어 RAM에 접근함
- 예시2. 프로세스 A,B가 서로 다른 물리 주소를 사용하는 경우
  - 프로세스 A는 베이스 레지스터 1000, 프로세스 B는 베이스 레지스터 4000
  - 프로세스 A와 B는 둘 다 논리 주소 50을 바라봄
  - A,B에 대한 변환된 물리 주소는 각각 1050, 4050
  - 서로 다른 프로세스라도 같은 논리 주소(50)를 가질 수 있지만, MMU가 베이스 레지스터를 활용해 각각 다른 물리 주소로 변환함 -> 프로세스 A와 B의 메모리가 충돌하지 않도록 보호하는 역할을 함
- 논리 주소와 물리 주소 개념이 중요한 이유
  1. 프로세스 간 메모리 충돌 방지
    - 서로 다른 프로그램이 같은 논리 주소를 사용할 수 있음
    - 그러나, 운영체제가 논리 주소를 서로 다른 물리 주소로 매핑하여 보호 
  2. 가상 메모리(Virtual Memory) 지원
    - RAM이 부족할 때 SSD/HDD 일부를 메모리처럼 사용 가능
    - 논리 주소가 존재하지만, 실제 물리 주소는 디스크에 있을 수도 있음
  3. 보안과 안정성
    - 프로세스마다 독립적인 논리 주소 공간을 부여
    - 하나의 프로세스가 다른 프로세스의 메모리에 직접 접근하지 못하도록 보호

#### 메모리 보호 기법
- 메모리 보호는 운영체제가 프로세스 간 메모리를 보호하고, 시스템의 안정성을 유지하는 핵심 기술
- 프로그램이 다른 프로그램의 메모리 공간을 침범하지 못하도록 막고, 악성 코드로부터 시스템을 보호하는 역할
- 왜 메모리 보호가 필요할까?
  - 문제점
  1. 프로세스 A가 프로세스 B의 메모리에 접근하면? => 데이터 오염, 충돌 발생
  2. 커널 메모리 영역을 사용자 프로그램이 수정하면? => 시스템 다운(블루 스크린)
  3. 악성 코드가 다른 프로세스의 메모리를 읽으면 => 보안 문제 발생(해킹)
  - 해결 방법
  1. 운영체제가 각 프로세스의 메모리 공간을 격리하고, 접근을 제한하는 기법을 사용
  2. 이를 위해 MMU, 페이지 테이블, 권한 감시 등이 동작
- 베이스 & 한계 레지스터 기반의 주요 메모리 보호 기법
  - 각 프로세스의 메모리 영역을 제한하는 가장 기본적인 기법
  - 동작 방식
    - 베이스 레지스터: 프로세스의 메모리 시작 주소 저장
    - 한계 레지스터: 프로세스가 사용할 수 있는 메모리 범위 지정
    - CPU가 메모리에 접근할 때, 이 범위를 벗어나면 오류 발생(예: Segmentation Fault)
  - 예시
    - 프로세스 A. 베이스 레지스터 1000, 한계 레지스터 500 -> 1000 ~ 1500만 사용 가능
    - 프로세스 B. 베이스 레지스터 2000, 한계 레지스터 600 -> 2000 ~ 2600만 사용 가능
    - 베이스 + 한계 레지스터를 통해 프로세스가 허용된 범위 내에서만 메모리를 사용할 수 있도록 제한
- 예제1. 논리 주소 1000번지의 데이터를 삭제하라
  - 프로세스 A의 베이스 레지스터값 = 5000(즉, 프로세스 A는 물리주소 5000부터 시작)
  - 한계 레지스터 값 = 2000(즉, 프로세스 A는 물리주소 5000 ~ 7000까지만 접근 가능)
  - 논리 주소 1000
  - 명령어: 논리 주소 1000번지의 데이터를 삭제하라
  - 변환 과정(논리 주소 -> 물리 주소)
    - 물리 주소 = 베이스 레지스터 + 논리 주소 = 5000 + 1000 = 6000
    - 논리 주소 1000은 물리 주소 6000으로 변환됨
    - 따라서, RAM의 6000번지 데이터를 삭제하면 됨
    - 한계 레지스터 체크 : 6000(계산된 물리 주소) <= 7000(한계 레지스터) -> 연산 수행 가능
- 예제2. 만약 논리 주소 2500번지의 데이터를 삭제하려고 하면?
  - 계산된 물리 주소 = 5000 + 2500 = 7500
  - 한계 레지스터 확인 : 7500 > 7000 (허용 범위를 초과)
    - 에러 발생(Segmentation Fault)
    - 운영체제가 접근을 차단하고, 프로세스를 종료할 수도 있음
- 프로세스 A와 B가 메모리를 사용하는 예시
  - 프로세스 A
    - 베이스 레지스터 = 4000 / 한계 레지스터 = 3000(즉, 4000 ~ 7000까지 사용 가능)
  - 프로세스 B
    - 베이스 레지스터 = 8000 / 한계 레지스터 = 2000(즉, 8000 ~ 10000까지 사용 가능)
  - 논리주소 0일 때, 프로세스 A 물리 주소 = 4000 / B 물리 주소 = 8000
  - 논리주소 500일 때, A = 4500 / B = 8500
  - 논리주소 1100일 때, A = 5100 / B = 9100
  - 논리주소 2000일 때, A = 6000 / B = 10000(마지막)
  - 논리주소 2500일 때, A = 접근 불가(7000 초과) / B = 접근 불가(10000 초과)
  - 이 방식 덕분에 프로세스 A가 B의 메모리에 침범할 수 없음(운영체제가 각 프로세스의 메모리 보호를 보장할 수 있음)

#### 캐시 메모리란?
- CPU가 빠르게 작업할 수 있도록 도와주는 초고속 메모리
- 캐시는 CPU 내부 또는 가까이에 존재하는 작은 고속 메모리
- RAM보다 빠르고, CPU가 자주 사용하는 데이터를 저장함, 데이터 접근 속도를 획기적으로 개선
- 왜 캐시 메모리가 필요할까?
  - CPU와 RAM간 속도 차이 문제를 해결하기 위해서 필요함(CPU: nano-second 단위로 연산, RAM: micro-second 단위로 반응)
  - 캐시가 없다면 매 연산마다 RAM 접근 -> 병목 발생 / 캐시는 RAM보다 훨씬 빠르게 접근 가능(수십-수백 배 빠름)
- L1, L2, L3 캐시
  - CPU 캐시는 3단계로 구성되어 효율을 극대화
  - L1 캐시
    - CPU 코어 내부에 위치하며, L1, L2, L3 캐시 중 가장 속도가 빠름
    - 크기는 보통 32~128KB 정도이며, 즉시 접근용으로 사용함
    - 레지스터 다음으로 빠른 속도를 보이며 CPU 코어당 1개씩 독립적으로 존재함
    - CPU가 가장 자주 사용하는 명령어나 데이터를 보관함
    - ALU와 레지스터 바로 옆에 위치하여, 거의 즉시 접근이 가능함
    - 성능에 가장 직접적인 영향을 미치는 캐시로 L1 캐시 미스가 발생하면 L2로 넘어감
  - L2 캐시
    - CPU 코어 내부에 위치하며, 속도가 L1 캐시 다음으로 빠름
    - 크기는 보통 256KB~1MB 정도이며, L1을 보조하는 역할을 함
    - L1 캐시보다 용량은 크지만 속도는 느리며, CPU 코어별로 존재함
    - L1 캐시를 보완하고 백업하는 목적으로 사용됨
    - L1 캐시 미스가 발생하면 L2 캐시를 바라보게 됨
    - 고급 CPU일수록 L2 캐시의 용량이 큼(서버, 게임용 CPU)
  - L3 캐시
    - CPU 코어 내부에 위치하거나 메인 보드에 있을 수 있음
    - RAM보다 빠른 속도를 보이며 코어 간 데이터를 공유하는 역할을 함
    - 여러 CPU 코어가 공유하는 형태로 RAM보다는 빠르지만 L1, L2 캐시보다는 느림
    - 보통 MB 단위의 용량을 보유함, 여러 CPU 코어가 데이터를 교환하는 목적으로 사용됨
    - 멀티 코어 환경에서 병목을 줄이는 역할, L1, L2 캐시 미스가 발생하면 L3에서 찾게됨(그렇게 해도 없으면 RAM에 접근)
    - L3 캐시가 크면 멀티 태스킹 성능이 향상됨
- 저장 장치 계층 구조(Memory Hierarchy)
  - 레지스터(속도가 빨라짐, 가격이 비싸짐, 용량이 작아짐) < L1 캐시 메모리 < L2 캐시 메모리 < L3 캐시 메모리 < RAM 메모리 < SSD, 하드디스크(속도가 느려짐, 가격이 저렴해짐, 용량이 커짐)
  - L1, L2 캐시는 CPU 내부에 위치하며, L3 캐시의 위치는 CPU 내부에 있을 수도 메인보드에 내장될 수 있음, CPU 메이커에 따라 달라질 수 있음

#### 참조 지역성(Locality of Reference) 원리
- 프로그램은 가까운 데이터를 반복해서 참조함
- 시간 지역성(Temporal Locality): 최근에 참조한 데이터를 다시 참조할 가능성이 높음(방금 쓴 것을 다시 또 사용, ex) 반복문을 통한 sum 계산) 
- 공간 지역성(Spatial Locality): 근처 메모리 위치를 함께 참조할 가능성이 높음(한 번 찾은 위치 근처도 같이 사용함)
- 캐시 히트(Cache Hit)와 캐시 미스(Cache Miss)
  - 데이터가 캐시에 있으면 빠르고, 없으면 느림
  - 캐시 히트(Cache Hit): CPU가 찾는 데이터가 캐시에 있음 -> 빠른 접근
  - 캐시 미스(Cache Miss): CPU가 찾는 데이터가 캐시에 없음 -> RAM/SSD에서 가져와야 함
  - 즉, 캐시 히트율이 높을수록 성능이 좋음
- 캐시 동작 과정
  - 캐시는 CPU와 메모리 사이의 중재자(CPU -> L1 캐시 -> L2 캐시 -> L3 캐시 -> RAM -> SSD)
  - 먼저 CPU가 데이터를 요청, L1 -> L2 -> L3 순서로 캐시를 확인, 모두 없으면 RAM에서 불러오고, 캐시에 저장
- 캐시의 종류
  - 데이터 캐시와 명령어 캐시가 존재함
  - 데이터 캐시(Data Cache): 연산에 사용할 데이터를 저장
  - 명령어 캐시(Instruction Cache): 실행할 명령어를 저장

#### RAM용량이 많으면 많을수록 조흥ㄴ가?
- RAM이 많으면 유리한 경우가 많지만, 필요 이상으로 많다고 성능이 향상되지는 않음
- RAM이 많을 떄의 장점
  - 멀티 태스킹 가능 : 여러 프로그램을 동시에 실행해도 느려지지 않음
  - 대용량 작업 처리 : 영상 편집, 3D 작업, 가상 머신 등 메모리를 많이 사용하는 작업을 처리 가능
  - 캐시 역할 강화 : 자주 사용하는 데이터는 앱을 더 많이 보관할 수 있음
  -> 그래서 RAM이 너무 부족하면 시스템이 심각하게 느려지거나, 아예 멈추는 경우도 생김
- RAM이 많다고 성능이 무조건 오르지는 않음
  - RAM을 사용하지 않으면 낭비! -> 실행 중인 프로그램이 사용하는 RAM 이상은 그냥 비어 있음
  - 애플리케이션이 적은 RAM만 요구 -> 웹서핑, 문서 작성만 한다면 8~16GB도 충분
  - 운영체제(OS)와 하드웨어의 한계 -> 32비트 OS는 4GB 이상의 램을 인식할 수 없음
  - 가격 대비 효율 하락 -> 64GB RAM의 경우에는 비싸지만 많이 사용하지 않는 경우가 많음
  - RAM이 많다고 성능이 떨어지진 않음
