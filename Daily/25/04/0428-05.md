## TIL

### 운영 체제란?
- 운영체제 = Operating Systms, 사용자와 하드웨어 사이의 중간에서 컴퓨터를 관리하고 제어하는 시스템 소프트웨어
- 운영체제는 컴퓨터 하드웨어를 직접 사용할 수 없는 사용자를 대신해, CPU, 메모리, 저장장치, 입출력 장치 등 자원을 효율적으로 관리하고 프로그램이 실행되도록 도와주는 관리자
- 운영체제의 주요 기능
  - 프로세스 관리: 실행 중인 프로그램(프로세스)의 실행 흐름과 상태 관리
  - 메모리 관리: 프로그램이 사용하는 메모리를 할당/회수
  - 파일 시스템 관리: 파일의 저장, 읽기, 권한 제어
  - 입출력 장치 관리: 키보드, 마우스, 디스크 등 하드웨어와의 연결
  - 자원 스케줄링: 여러 작업 사이의 CPU 시간 분배, 우선순위 결정
  - 보안 및 권한 제어: 사용자/프로세스의 접근을 통제, 시스템 보호
- 운영 체제가 왜 필요한가?
  - 컴퓨터 하드웨어 자체는 운영체제라는 프로그램 없이는 아무것도 할 수 없음
  - 운영체제가 존재해야 애플리케이션 실행, 파일 저장, 마우스 클릭 등의 동작이 가능함
  - 운영체제가 없으면 사용자는 CPU나 메모리를 직접 제어해야함 -> 현실적으로 불가능
- 좀 더 자세히 알아본다면...
  1. 사용자 <-> 하드웨어 사이의 인터페이스 제공자
    - 컴퓨터는 하드웨어는 이진수(0 또는 1)로만 동작함 -> 사람이 직접 다루기 어려움
    - 운영체제는 이 복잡한 하드웨어 동작을 명령어, GUI, API 등으로 추상화하여 사용자에게 제공
    - 예를 들어, 사용자가 파일 저장을 누르면 OS는 저장 위치 결정, 권한 확인, 디스크 블록 관리까지 자동으로 수행함
    - 운영체제가 없으면 사용자가 직접 디스크 주소, I/O 명령어, CPU 레지스터를 제어해야함
  2. 자원(Resourec)의 효율적인 분배자
    - 컴퓨터는 한정된 자원을 가지고 있고, 그 자원을 바탕으로 여러 작업을 동시에 수행함 -> CPU, RAM, HDD, SSD, 네트워크 등
    - OS는 여러 사용자/프로세스가 동시에 자원을 요청할 때 공정하고 효율적인 분배를 스케줄링 알고리즘으로 해결함
    - 예를 들어, 동시에 10개의 요청이 들어온다고 했을 때 CPU는 어떤 요청을 먼저 처리할 것인지? 어떤 프로그램이 메모리를 얼만큼 사용할 수 있는지 등에 대한 결정을 OS 레벨에서 진행
  3. 프로그램 실행을 위한 운영 기반 제공자
    - 운영체제가 있어야 사용자는 프로그램을 실제로 실행할 수 있음
    - 프로그램을 컴퓨터에서 실행시켜 프로세스가 되려면 OS가 다음 작업을 수행함
      - 실행파일을 메모리에 적재
      - 프로세스 테이블 생성
      - PID부여, 권한 설정
- 실무에서의 OS 이해 필요성
  - 백엔드 개발자? -> 리눅스 환경에서 배포/디버깅, 프로세스 관리 등
  - 클라우드 엔지니어? -> 가상 머신, 컨테이너, 스케줄링 시스템 관리 등
  - 보안 담당자? -> 사용자 권한, 접근 제어, 로그 분석 등
  - 시스템 관리자? -> OS 패치, 커널 설정, 메모리 튜닝 등
  - 프론트엔드 개발자? -> 크로스 플랫폼 환경에 대한 이해(windows, macOS, linux, ...)

#### 커널이란?
- 운영체제를 이해하기 위해서는 "커널"을 필수적으로 이해해야함
- 운영체제의 핵심 구성 요소, 하드웨어와 소프트웨어 사이에서 자원을 관리하고 중재하는 프로그램 집합
- 컴퓨터가 부팅된 이후부터 꺼질 때까지 항상 메모리에 상주, 사용자 프로그램은 직접 하드웨어에 접근하지 않고, 커널을 통해 간접적인 접근을 함
- 커널이 담당하는 핵심 역할
  - 프로세스 관리, 프로세스 생성, 종료, 스케줄링, 컨텍스트 스위칭등
  - 메모리 관리, 물리/가상 메모리 매핑, 페이지 교체, 접근 보호 등
  - 파일 시스템 관리, 파일 읽기/쓰기, 디렉토리 구조 관리 등
  - 입출력 관리, 장치 드라이버를 통해 키보드, 디스크, 네트워크 등과 통신
  - 시스템 호출 인터페이스 제공, 사용자 프로그램이 커널 기능을 요청할 수 있게함
- 커널과 사용자 모드
  - 운영체제는 기능을 수행하기 위해 사용자 모드와 커널 모드를 구분함
  - 사용자 모드: 운영체제 서비스를 제공받을 수 없는 실행 모드로 커널 영역의 코드를 실행할 수 없음
  - 커널 모드: 운영체제 서비스를 제공받을 수 있는 실행 모드로 커널 영역의 코드를 실행할 수 있음
  - 시스템 호출: 사용자 프로그램이 커널에 기능을 요청할 때 사용하는 호출
- 이중 모드(dual mode)
  - 운영체제가 사용자 프로그램과 시스템(커널)을 구분해서 동작시키기 위해 도입된 보호 매커니즘
  - 사용자 모드(User mode)와 커널 모드(Kernel mode) 두 가지 실행 모드를 지원함
  - 왜 이중 모드가 필요한가?
    - 일반 프로그램이 CPU, 메모리, I/O 장치에 직접 접근하면 실수 혹은 악의적인 코드로 시스템 전체가 망가질 수 있음
    - 이를 방지하기 위해 사용자 프로그램은 제한된 권한으로 실행(User mode)
    - 운영체제(커널)는 전체 시스템 자원에 대한 완전한 권한을 가짐(Kernel mode)
  - 예시
    - 사용자가 웹 브라우저를 실행 -> 사용자 모드 / 브라우저가 파일을 저장하려고 write() 호출 -> 시스템 호출 발생 + 커널 모드 전환
    - 커널이 디스크에 데이터 쓰기 -> 커널 모드 / 작업 완료 후, 다시 사용자 모드로 복귀 -> 사용자 모드 / 즉, 커널 모드와 사용자 모드 간 전환을 통해 시스템을 보호함
- 시스템 호출(System call)
  - 사용자 프로그램이 커널에 기능을 요청할 때 사용하는 인터페이스(파일 저장, 데이터 읽기, 프로세스 생성 등)
  - 왜 필요한가?
    - 사용자 모드에서는 하드웨어나 시스템 자원에 직접 접근할 수 없음
    - 따라서, 사용자 프로그램은 커널에게 도움이 필요해!라는 요청을 하게 되고, 그 요청이 바로 시스템 호출(system call)
- 만약 이중 모드와 시스템 호출이 없다면?
  - 모든 사용자 프로그램이 메모리, 디스크, 네트워크를 제멋대로 조작할 수 있게됨
  - 따라서, 운영체제의 안정성과 보안이 심각하게 무너짐
  - 서버, 클라우드, 금융 시스템 등에서는 이런 방식으로는 운영할 수 없음
- 시스템 호출의 종류
  - 프로세스 관리: fork(), execve(), exit(), waitpid() -> 새 자식 프로세스 생성, 프로세스 종료 등
  - 파일 관리: open(), close(), read(), write(), stat() -> 파일 엵기, 닫기, 읽기 등
  - 디렉토리 관리: chdir(), mkdir(), rmdir() -> 작업 디렉토리 변경 등
  - 파일 시스템 관리: mount(), umount() -> 파일 시스템 마운트 및 해제 등

#### 모놀리식 커널과 마이크로 커널
- 모놀리식 커널(Monolithic Kernel)
  - 모든 운영체제 핵심 기능(파일 시스템, 메모리 프로세스 등)이 하나의 커널 공간 안에 구현된 구조
  - 하나의 덩어리 같은 개념, 함수 호출로 커널 내부 기능들 간 직접 연결
  - 예: 디스크 드라이버도 커널 안에 함께 있음
  - 장점
    - 성능이 빠름(모든 기능이 하나의 공간에서 실행 -> 함수 호출로 비용이 낮음)
    - 구현이 비교적 단순함(모든 기능이 같은 커널 내에서 동작)
  - 단점
    - 한 곳에서 오류 발생 시 커널 전체가 크래시할 위험
    - 유지보수가 얼벼고, 기능 추가시 복잡도 증가
  - 대표 예시로는 Linux, 초기 Unix 등이 있음  
- 마이크로 커널(Micro-kernel)
  - 운영체제의 핵심 기능만 커널에 남기고, 나머지 서비스는 사용자 공간에 실행되도록 분리한 구조
  - 커널에는 필수 기능만 존재함(메모리 관리, 스케줄링, IPC)
  - 파일 시스템, 드라이버 등은 모두 사용자 공간에서 별도 프로세스로 동작
  - 장점
    - 커널이 작고 모듈화되어 있어 안정성과 보안성이 높음. 일부 기능만 고쳐도 전체 시스템에는 영향이 적음
    - 오류가 발생하면 커널 크래시 없이 해당 모듈만 재시작 가능
  - 단점
    - 성능 저하 가능(모든 서비스 간 통신이 필요함)
    - 구현이 복잡함
  - 대표 예시로는 macOS가 있음

#### 가상 머신(Virtual Machine)
- 소프트웨어적으로 만들어낸 가상 컴퓨터
- 가상 머신에 새로운 운영체제와 응용프로그램을 설치하고 실행할 수 있음
- 가상 머신 또한 하나의 사용자 프로그램 따라서, 사용자 모드로 동작하게 됨

-----

### 프로그램, 프로세스, 스레드
- 사용자에게 프로그램이라는 단어는 매우 친숙한 단어, 하지만 운영체제 입장에서 보면 프로그램은 단순한 정적인 파일에 불과함
- 이 프로그램은 메모리에 올라가고, CPU가 실행 가능한 상태가 되었을 때 -> 프로세스(Process)
- 즉, 프로세스 = 운영체제가 관리하는 실행 단위, 각각의 프로세스에 메모리, CPU 시간 등을 분리해서 할당함
- 만약 프로그램 하나가 동시에 여러 작업을 수행한다면?
  - 웹 브라우저가 탭마다 페이지를 렌더링하고, 다운로드도 동시에 해야 하는 경우 -> 스레드(Thread) 필요
- 스레드: 프로세스 내에서 실행되는 경량 실행 단위 + 프로세스가 가진 자원을 공유하면서 각자 독립적으로 실행됨

#### 운영체제에서의 프로세스
- 운영체제는 프로세스를 단순히 돌고 있는 무언가로 보는 것은 아님, 각 프로세스는 다음과 같은 리소스를 독립적으로 가지고 운영체제의 감시 하에 실행됨
  - 고유한 PID(Process ID)
  - 고유한 메모리 공간(코드, 데이터, 힙, 스택 영역)
  - 파일 디스크립터 테이블(열려 있는 파일 목록)
  - 레지스터 값(CPU 상태, PC등)
  - 스케줄링 정보(우선순위, 대기 시간 등)
- 이러한 모든 정보는 운영체제가 유지하는 PCB(Process Control Block)에 저장됨

#### PCB(Process Control Block)
- 운영체제가 각 프로세스를 관리하기 위해 사용되는 자료구조, 프로세스 하나당 하나의 PCB가 생성됨
- 해당 프로세스에 대한 모든 정보와 상태가 저장됨
- 운영체제가 관리하는 정보는 다음과 같음(이 정보를 기반으로 실행하거나 중단할 때 사용할 수 있음)
  - 식별 정보: PID, PPID, 사용자 ID 등
  - 프로세스 상태: READY, RUNNING, WAITING, TERMINATED 등 현재 상태
  - 레지스터 정보: CPU 사용중이라던 레지스터, PC(Program Counter), SP(Stack Pointer)등
  - 메모리 정보: 주소 공간 시간/끝, 코드/데이터/스택/힙 위치
  - 스케줄링 정보: 우선순위, 스케줄링 큐 위치, CPU 시간 등
  - I/O 상태: 열린 파일, 장치 핸들, 소켓 등
  - 시스템 자원: 환경 변수, 시그널 핸들러 정보 등
- PCB가 사용되는 상황
  - 컨텍스트 스위칭. CPU가 A 프로세스에서 B프로세스로 전환되는 경우
    - A의 레지스터 정보 등은 PCB에 저장, B의 PCB에 저장된 정보를 거내 CPU에 로드
  - 프로세스 상태 추적.
    - 운영체제는 PCB의 상태 값을 보고 Ready Queue, Waiting Queue 등을 관리, 스케줄러가 CPU 할당 시 활용
  - 프로세스 종료 시.
    - PCB를 참조해 자원 정리 후 제거, 부모가 wait() 호출 시 종료 코드 반환
- 컨텍스트 스위칭(Context Switching)
  - 운영체제가 CPU를 사용하는 프로세스 또는 스레드를 바꾸는 과정에서 이전 실행 정보(문맥)을 저장하고 새로운 프로세스/스레드의 정보를 불러오는 작업을 의미함
  - 즉, A작업을 하다가 멈추고, B작업으로 바꾸기 위한 준비 과정
  - 왜 컨텍스트 스위칭이 필요한가?
    - 하나의 CPU가 여러 작업을 동시에 처리하는 것처럼 보이게 하기 위해서
    - 사용자가 동시에 여러 프로그램을 실행할 수 있도록 하기 위해
    - 하나의 프로세스가 I/O 대기 중일 때, 다른 프로세스에게 CPU를 양보하기 위해
    - CPU는 실제로 한 순간에 하나의 작업만 수행하지만, 빠른 컨텍스트 스위칭으로 다중 작업이 가능해짐
- 어떤 컨텍스트를 관리하는걸까?
  - 컨텍스트 스위칭 시 운영체제는 PCB를 통해 다음 정보를 저장/복원함
    - 레지스터 값: 일반 레지스터, 프로그램 카운터, 스택 포인터 등
    - 메모리 상태: 주소 공간 정보
    - CPU 상태: 우선순위, 시간 정보 등
- 컨텍스트 스위칭의 오버헤드(단점)
  - CPU 시간 낭비: 작업 전환 자체에 시간이 소모됨
  - 과도한 스위칭: 성능 저하 유발
  - 즉, 너무 자주 컨텍스트 스위칭이 일어나면 실제 연산보다 전환만 하다 끝나는 현상이 발생할 수 있음

#### 프로세스의 메모리 구조
- 운영체제는 프로세스를 위한 독립된 주소 공간을 할당하며, 내부 구조는 다음과 같이 나뉨
- Stack: 함수 호출 시마다 쌓이고, 호출이 끝나면 제거됨(LIFO 구조)
  - Stacktrace? 에러가 발생했을 때, 현재 함수가 호출된 경로를 역추적해서 출력한 것(즉, 어떤 함수가 어떤 함수를 호출하다가, 어디서 오류가 터졌는지 보여주는 리스트) 
- Heap: 프로그램 실행 중 동적으로 메모리를 할당할 수 있는 공간
  - 프로그램을 만드는 사용자(개발자)가 직접 할당할 수 있는 저장 공간
  - 힙 영역에 할당된 메모리는 다시 반환되어야함, 만약 메모리가 반환되지 않으면? -> 메모리 누수 
- Data: 컴파일 시 초기화된 전역/정적 변수
- Code/Text: 실행 파일의 기계어가 로딩되어 있는 영역

#### 프로세스 상태(state)와 전이(transition)
- 운영체제는 수많은 프로세스를 동시에 다루기 때문에 각 프로세스의 현재 상태를 아래와 같이 구분함
- NEW: 생성 중(아직 실행전)
- READY: CPU 할당 대기중
- RUNNING: CPU를 잡고 실행중
- WAITING: I/O 등 이벤트 대기 중
- TERMINATED: 실행 종료됨
- 이 상태들은 이벤트 발생/스케줄링예 따라 전이됨 -> 예를 들면, 파일 읽기 요청 -> WAITING 상태 -> 완료 후 READY -> CPU 할당되면 RUNNING
- 실무 예시(클라이언트가 REST API 호출 -> 서버가 DB 조회 -> 외부 HTTP 호출 -> 조립 후 결과 응답)
  1. [READY]
    - 웹 서버 (Spring Boot 등)는 미리 실행되어 대기 중
    - 클라이언트 요청을 기다리는 중 -> READY 상태 
  2. [RUNNING]
    - 클라이언트 API 호출 -> 커널이 요청 수신 -> 웹 서버 프로세스가 CPU를 할당받아 실행됨
    - 비즈니스 로직 수행을 위해 메소드 진입
  3. [WAITING]
    - DB 조회를 위해 JDBC 또는 ORM을 통해 비동기 또는 동기 I/O 요청 발생
    - CPU 반환 -> I/O 큐에서 DB 응답 대기
    - WAITING 상태로 전이됨
  4. [READY] -> [RUNNING]
    - DB에서 데이터 도착
    - 프로세스 READY 상태로 이동
    - 그 다음에는 스케줄러에 의해 다시 CPU를 할당 -> RUNNING 상태로 이동
  5. [WAITING]
    - DB 결과를 바탕으로 외부 API 호출 수행
    - 일반적으로 HttpClient, RestTemplate 등을 사용
    - 다시 WAITING 상태로 이동
  6. [READY] -> [RUNNING]
    - 외부 API 응답 도착 -> 프로세스 READY 상태로 이동
    - 다시 CPU를 받아 RUNNING 상태로 실행
  7. [RUNNING] -> 응답 조립 + 반환 -> [TERMINATED]

#### 프로세스 계층 구조
- 운영체제에서 한 프로세스가 다른 프로세스를 생성할 수 있는 구조
- 이 때 생성한 프로세스를 자식 프로세스, 생성한 쪽을 부모 프로세스라고 부름
- 프로세스가 어떻게 상하 구조(부모-자식 관계)를 조직하고 관리하는지를 설명하는 개념
- 프로세스가 트리 구조처럼 만들어지는 것을 프로세스 계층 구조라고 함
- 이 구조는 특히 Unix/Linux 시스템에서 중요한 개념
- 계층 구조의 핵심 개념
  - 하나의 부모 프로세스가 여러 자식 프로세스를 만들 수 있음
  - 자식 프로세스는 고유의 PID를 가지지만, 부모 PID를 통해 상위 관계를 가짐
  - 자식은 종료되면 부모가 wait()를 통해 종료 상태를 수거
  - 부모보다 먼저 종료된 자식은 좀비 프로세스가 될 수 있음
- 부모-자식 관계의 의미
  - 리소스 상속: 부모가 가진 환경 변수, 파일 디스크립터 등을 자식이 복사해서 사용
  - 종료 처리 책임: 부모는 자식의 종료를 수거해야함
  - 오케스트레이션 구조: 여러 자식 프로세스를 통해 작업을 병렬/비동기로 분산 가능
- 대표적인 계층 구조 예시
  - Unix/Linux 환경
    - 최상위: systemd 또는 init(PID) -> 시스템의 최초 프로세스
    - 이후의 모든 프로세스는 여기에 의해 간접적으로 생성됨
    - 사용자의 쉘(bash)도 sshd나 gnome-terminal 등의 자식 프로세스
    - 그 안에서 실행되는 vim, node도 각각 하위 자식 프로세스
- 프로세스 생성 기법
  - 프로세스는 프로세스를 낳는다
  - 운영체제에서는 새로운 프로세스는 기존 프로세스에 의해 생성됨
  - 즉, 부모 프로세스가 자식 프로세스를 생성하는 방식
  - 시스템 부팅 시 최초로 생성되는 프로세스는 init 또는 systemd이며, 그 이후의 모든 프로세스는 그 아래에서 트리 형태로 파생됨
- 프로세스 생성의 기본 흐름(Unix, Linux 계열, 다음과 같은 시스템 호출 조합으로 자식 프로세스를 생성함)
  1) fork() - 현재 실행중인 프로세스를 복제해서 새로운 프로세스를 생성, 부모와 거의 동일한 복사본이 만들어짐(PID만 다름)
  2) exec() 계열(execv, execve, execlp 등) - 복제된 자식 프로세스의 코드를 다른 프로그램으로 교체
  3) wait() or waitpid() - 부모가 자식 프로세스의 종료를 기다리고, 종료 상태를 수거

#### 스레드란?
- 
