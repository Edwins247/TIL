## TIL

### 운영 체제란?
- 운영체제 = Operating Systms, 사용자와 하드웨어 사이의 중간에서 컴퓨터를 관리하고 제어하는 시스템 소프트웨어
- 운영체제는 컴퓨터 하드웨어를 직접 사용할 수 없는 사용자를 대신해, CPU, 메모리, 저장장치, 입출력 장치 등 자원을 효율적으로 관리하고 프로그램이 실행되도록 도와주는 관리자
- 운영체제의 주요 기능
  - 프로세스 관리: 실행 중인 프로그램(프로세스)의 실행 흐름과 상태 관리
  - 메모리 관리: 프로그램이 사용하는 메모리를 할당/회수
  - 파일 시스템 관리: 파일의 저장, 읽기, 권한 제어
  - 입출력 장치 관리: 키보드, 마우스, 디스크 등 하드웨어와의 연결
  - 자원 스케줄링: 여러 작업 사이의 CPU 시간 분배, 우선순위 결정
  - 보안 및 권한 제어: 사용자/프로세스의 접근을 통제, 시스템 보호
- 운영 체제가 왜 필요한가?
  - 컴퓨터 하드웨어 자체는 운영체제라는 프로그램 없이는 아무것도 할 수 없음
  - 운영체제가 존재해야 애플리케이션 실행, 파일 저장, 마우스 클릭 등의 동작이 가능함
  - 운영체제가 없으면 사용자는 CPU나 메모리를 직접 제어해야함 -> 현실적으로 불가능
- 좀 더 자세히 알아본다면...
  1. 사용자 <-> 하드웨어 사이의 인터페이스 제공자
    - 컴퓨터는 하드웨어는 이진수(0 또는 1)로만 동작함 -> 사람이 직접 다루기 어려움
    - 운영체제는 이 복잡한 하드웨어 동작을 명령어, GUI, API 등으로 추상화하여 사용자에게 제공
    - 예를 들어, 사용자가 파일 저장을 누르면 OS는 저장 위치 결정, 권한 확인, 디스크 블록 관리까지 자동으로 수행함
    - 운영체제가 없으면 사용자가 직접 디스크 주소, I/O 명령어, CPU 레지스터를 제어해야함
  2. 자원(Resourec)의 효율적인 분배자
    - 컴퓨터는 한정된 자원을 가지고 있고, 그 자원을 바탕으로 여러 작업을 동시에 수행함 -> CPU, RAM, HDD, SSD, 네트워크 등
    - OS는 여러 사용자/프로세스가 동시에 자원을 요청할 때 공정하고 효율적인 분배를 스케줄링 알고리즘으로 해결함
    - 예를 들어, 동시에 10개의 요청이 들어온다고 했을 때 CPU는 어떤 요청을 먼저 처리할 것인지? 어떤 프로그램이 메모리를 얼만큼 사용할 수 있는지 등에 대한 결정을 OS 레벨에서 진행
  3. 프로그램 실행을 위한 운영 기반 제공자
    - 운영체제가 있어야 사용자는 프로그램을 실제로 실행할 수 있음
    - 프로그램을 컴퓨터에서 실행시켜 프로세스가 되려면 OS가 다음 작업을 수행함
      - 실행파일을 메모리에 적재
      - 프로세스 테이블 생성
      - PID부여, 권한 설정
- 실무에서의 OS 이해 필요성
  - 백엔드 개발자? -> 리눅스 환경에서 배포/디버깅, 프로세스 관리 등
  - 클라우드 엔지니어? -> 가상 머신, 컨테이너, 스케줄링 시스템 관리 등
  - 보안 담당자? -> 사용자 권한, 접근 제어, 로그 분석 등
  - 시스템 관리자? -> OS 패치, 커널 설정, 메모리 튜닝 등
  - 프론트엔드 개발자? -> 크로스 플랫폼 환경에 대한 이해(windows, macOS, linux, ...)

#### 커널이란?
- 운영체제를 이해하기 위해서는 "커널"을 필수적으로 이해해야함
- 운영체제의 핵심 구성 요소, 하드웨어와 소프트웨어 사이에서 자원을 관리하고 중재하는 프로그램 집합
- 컴퓨터가 부팅된 이후부터 꺼질 때까지 항상 메모리에 상주, 사용자 프로그램은 직접 하드웨어에 접근하지 않고, 커널을 통해 간접적인 접근을 함
- 커널이 담당하는 핵심 역할
  - 프로세스 관리, 프로세스 생성, 종료, 스케줄링, 컨텍스트 스위칭등
  - 메모리 관리, 물리/가상 메모리 매핑, 페이지 교체, 접근 보호 등
  - 파일 시스템 관리, 파일 읽기/쓰기, 디렉토리 구조 관리 등
  - 입출력 관리, 장치 드라이버를 통해 키보드, 디스크, 네트워크 등과 통신
  - 시스템 호출 인터페이스 제공, 사용자 프로그램이 커널 기능을 요청할 수 있게함
- 커널과 사용자 모드
  - 운영체제는 기능을 수행하기 위해 사용자 모드와 커널 모드를 구분함
  - 사용자 모드: 운영체제 서비스를 제공받을 수 없는 실행 모드로 커널 영역의 코드를 실행할 수 없음
  - 커널 모드: 운영체제 서비스를 제공받을 수 있는 실행 모드로 커널 영역의 코드를 실행할 수 있음
  - 시스템 호출: 사용자 프로그램이 커널에 기능을 요청할 때 사용하는 호출
- 이중 모드(dual mode)
  - 운영체제가 사용자 프로그램과 시스템(커널)을 구분해서 동작시키기 위해 도입된 보호 매커니즘
  - 사용자 모드(User mode)와 커널 모드(Kernel mode) 두 가지 실행 모드를 지원함
  - 왜 이중 모드가 필요한가?
    - 일반 프로그램이 CPU, 메모리, I/O 장치에 직접 접근하면 실수 혹은 악의적인 코드로 시스템 전체가 망가질 수 있음
    - 이를 방지하기 위해 사용자 프로그램은 제한된 권한으로 실행(User mode)
    - 운영체제(커널)는 전체 시스템 자원에 대한 완전한 권한을 가짐(Kernel mode)
  - 예시
    - 사용자가 웹 브라우저를 실행 -> 사용자 모드 / 브라우저가 파일을 저장하려고 write() 호출 -> 시스템 호출 발생 + 커널 모드 전환
    - 커널이 디스크에 데이터 쓰기 -> 커널 모드 / 작업 완료 후, 다시 사용자 모드로 복귀 -> 사용자 모드 / 즉, 커널 모드와 사용자 모드 간 전환을 통해 시스템을 보호함
- 시스템 호출(System call)
  - 사용자 프로그램이 커널에 기능을 요청할 때 사용하는 인터페이스(파일 저장, 데이터 읽기, 프로세스 생성 등)
  - 왜 필요한가?
    - 사용자 모드에서는 하드웨어나 시스템 자원에 직접 접근할 수 없음
    - 따라서, 사용자 프로그램은 커널에게 도움이 필요해!라는 요청을 하게 되고, 그 요청이 바로 시스템 호출(system call)
- 만약 이중 모드와 시스템 호출이 없다면?
  - 모든 사용자 프로그램이 메모리, 디스크, 네트워크를 제멋대로 조작할 수 있게됨
  - 따라서, 운영체제의 안정성과 보안이 심각하게 무너짐
  - 서버, 클라우드, 금융 시스템 등에서는 이런 방식으로는 운영할 수 없음
- 시스템 호출의 종류
  - 프로세스 관리: fork(), execve(), exit(), waitpid() -> 새 자식 프로세스 생성, 프로세스 종료 등
  - 파일 관리: open(), close(), read(), write(), stat() -> 파일 엵기, 닫기, 읽기 등
  - 디렉토리 관리: chdir(), mkdir(), rmdir() -> 작업 디렉토리 변경 등
  - 파일 시스템 관리: mount(), umount() -> 파일 시스템 마운트 및 해제 등

#### 모놀리식 커널과 마이크로 커널
- 모놀리식 커널(Monolithic Kernel)
  - 모든 운영체제 핵심 기능(파일 시스템, 메모리 프로세스 등)이 하나의 커널 공간 안에 구현된 구조
  - 하나의 덩어리 같은 개념, 함수 호출로 커널 내부 기능들 간 직접 연결
  - 예: 디스크 드라이버도 커널 안에 함께 있음
  - 장점
    - 성능이 빠름(모든 기능이 하나의 공간에서 실행 -> 함수 호출로 비용이 낮음)
    - 구현이 비교적 단순함(모든 기능이 같은 커널 내에서 동작)
  - 단점
    - 한 곳에서 오류 발생 시 커널 전체가 크래시할 위험
    - 유지보수가 얼벼고, 기능 추가시 복잡도 증가
  - 대표 예시로는 Linux, 초기 Unix 등이 있음  
- 마이크로 커널(Micro-kernel)
  - 운영체제의 핵심 기능만 커널에 남기고, 나머지 서비스는 사용자 공간에 실행되도록 분리한 구조
  - 커널에는 필수 기능만 존재함(메모리 관리, 스케줄링, IPC)
  - 파일 시스템, 드라이버 등은 모두 사용자 공간에서 별도 프로세스로 동작
  - 장점
    - 커널이 작고 모듈화되어 있어 안정성과 보안성이 높음. 일부 기능만 고쳐도 전체 시스템에는 영향이 적음
    - 오류가 발생하면 커널 크래시 없이 해당 모듈만 재시작 가능
  - 단점
    - 성능 저하 가능(모든 서비스 간 통신이 필요함)
    - 구현이 복잡함
  - 대표 예시로는 macOS가 있음

#### 가상 머신(Virtual Machine)
- 소프트웨어적으로 만들어낸 가상 컴퓨터
- 가상 머신에 새로운 운영체제와 응용프로그램을 설치하고 실행할 수 있음
- 가상 머신 또한 하나의 사용자 프로그램 따라서, 사용자 모드로 동작하게 됨
