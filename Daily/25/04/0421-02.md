## TIL

### 전역 상태 관리
- 로그인한 유저 정보, Theme Style 등 웹 애플리케이션을 개발하다 보면 전역 상태로 관리해야 하는 값들이 꽤 많이 생김
- 이 전역적으로 상태를 처리하려면 App.js에서 전역 상태 관리를 하면 하위 컴포넌트 및 페이지들에서 모두 state를 쓸 수 있음
- 먼저 React에서 Context API를 활용해서 전역 상태 관리를 해 볼 수 있음
```jsx
import React, { createContext, useState } from "react";

export const UserContext = createContext();

export default function UserStore(props) {
    const [job, setJob] = useState("FE-developer");

    const user = {
        name: "hwarari",
        job: "FE-developer",
        changeJob: (updatedJob) => setJob(updatedJob),
    };

    return <UserContext.Provider value={user}>{props.children}</UserContext.Provider>
}
```
```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import MainPage from "./components/MainPage";
import TechPage from "./components/TechPage";
import BlogPage from "./components/BlogPage";
import JavascriptPage from "./components/JavascriptPage";
import ReactPage from "./components/ReactPage";
import ReactDocPage from "./components/ReactDocPage";

function App() {
  // root url : main page component
  // tech url : tech page component
  // blog url : blog page component

  return (
    <UserStore>
      <BrowserRouter>
        <Routes>
          <Route path={"/"} element={<MainPage />} />
          <Route path={"tech"} element={<TechPage />}>
            <Route path="javascript" element={<JavascriptPage />} />
            <Route path="react" element={<ReactPage />} />
            <Route path="react/:docId" element={<ReactDocPage />} />
          </Route>
          <Route path={"blog"} element={<BlogPage />} />
        </Routes>
      </BrowserRouter>
    </UserStore>
  );
}

export default App;
```
```jsx
import React, { useContext } from "react";
import { UserContext } from "../store/user";

export default function BlogPage() {
  const value = useContext(UserContext);
  return (
    <div>
      <h1>BlogPage</h1>
    </div>
  );
}
```
- 이때, UserStore의 위치에 따라서 전역 state를 useContext로 쓸 수 있는 상황이 달라짐
- [공식문서](https://ko.legacy.reactjs.org/docs/context.html)

### useReducer
- [공식문서](https://ko.legacy.reactjs.org/docs/hooks-reference.html#usereducer)
- 기본적으로 useState로 상태 처리를 하는데, useReducer를 사용할 경우, state처리와 이에 대한 dispatch를 통한 상태 업데이트를 할 수 있음
- 보통 다수의 하윗값을 포함하는 복잡한 정적 로직을 만들거나, 다음 state가 이전 state에 의존적인 경우나 자세한 업데이트를 트리거 하는 콜백 대신 dispatch를 쓰기에 이러한 상황에서 쓰기 용이함
- 이 때, 컴포넌트 안에서 쓰는 경우도 많지만 앞서 배운 Context API와 같이 쓰는 경우도 많음
- 아래와 같이 사용할 수 있음
```jsx
import React, { createContext, useState, useReducer } from "react";

export const UserContext = createContext();

const initialUser = {
    name: "hwarari",
    job: "FE-developer",
}

const userReducer = (state, action) => {
    switch (action.type) {
        case "changeJob":
            // state의 job에 해당하는 데이터를 action.text
            return { ...state, job: action.text }
            break;
        
        default:
            break;
    }
}

export default function UserStore(props) {
    // const [job, setJob] = useState("FE-developer");

    const [user, dispatch] = useReducer(userReducer, initialUser);
    console.log(user);

    // const user = {
    //     name: "hwarari",
    //     job: "FE-developer",
    //     changeJob: (updatedJob) => setJob(updatedJob),
    // };

    return <UserContext.Provider value={dispatch}>{props.children}</UserContext.Provider>
}
```
```jsx
import React, { useContext } from "react";
import { UserContext } from "../store/user";

export default function BlogPage() {
  const dispatch = useContext(UserContext);


  return (
    <div>
      <h1>BlogPage</h1>
      <button onClick={() => dispatch({ type: "changeJob", text: "BE-developer"})}>Change Job</button>
    </div>
  );
}
```

### Redux
- Redux는 전역 상태 관리를 도와주는 라이브러리임, 앞서 React 내장된 Context API + useState or useReducer를 쓸 수 있음
- Redux는 내장된 React의 기능보다 성능이 좋음, 왜냐하면 Context API 같은 경우, 데이터를 저장하고 있던 없던 호출 및 상태를 불러오게 된다면 무조건 리렌더링을 함
- 이를 성능을 고려해서 처리한다면 코드가 복잡해지게 됨, 그래서 redux를 씀
- [공식문서](https://redux.js.org/introduction/getting-started)
- 이 redux는 상태가 하나의 저장소 안에 객체트리에 저장됨
- Redux에서 state를 변경하여 UI가 변경되면 그에 따른 Dispatch에 따라 State를 업데이트 하는 Flow로 진행됨
- action 객체를 가져와서 데이터를 넣거나 처리하면 dispatch가 실행되고 그에 따라 reducer에서 state가 변경되고 UI가 업데이트가 됨. 그런 매커니즘임.
- 이에 대해서 Redux를 위해 별도의 Context API와 같이 만들어서 관리 및 처리할 수 있음(state와 여러가지 로직 처리를 위한용으로)
- 그리고 Redux Toolkit으로 Redux 로직을 작성하기 위해서 여러가지 패키지와 함수가 있는데, 이 라이브러리를 같이 쓸 수 있음
- [Redux Toolkit](https://redux-toolkit.js.org/introduction/getting-started)
- 이러한 Redux는 비동기처리 & 상태 관리로 응용할 수 있음
- 만약 로그인 요청 후 서버에 응답을 받으면 그 응답 받은 유저 정보를 전역 스토어에 저장하는 케이스가 있다면
  1. 컴포넌트의 useEffect내에서 API 호출하고, 응답 받은 결과를 스토어에 업데이트함(dispatch 활용)
  2. 컴포넌트의 useEffect내에서 dispatch로 액션 객체만을 보내고 user Store의 reducer 안에서 API를 호출하고, 응답 받은 결과를 스토어에 업데이트함
    - 하지만 2번의 방법은 할 수 없음 왜냐하면 reducer는 순수함수이기에 동일한 인자가 주어졌을 때 항상 동일한 결과를 반환하기 떄문임
  - 이럴 때 middleware를 활용해야함
  - action 객체를 dispatch -> middleware -> Reducer -> Store 업데이트
    - 이러한 middleware는 action 객체를 dispatch하고, Reducer가 해당 action 객체에 대해 Store를 업데이트 하기 전에 추가적인 작업을 할 수 있게 도와줌(비동기 처리, 로깅 등)
- 이러한 middleware 라이브러리로 여러가지 있음
- 비동기 처리를 위한 middleware
  - redux-thunk
    - dispatch에 action 객체가 아닌 thunk 함수를 전달함, 가장 간단하고 진입 장벽이 낮음
  - redux-saga
    - generator를 활용하고 redux-thunk가 가지고 있는 아쉬움을 보완함
  - redux-observable
    - RxJS를 기반으로 하고 진입 장벽이 높음
- 아래와 같이 만들어 볼 수 있음 먼저 기본적인 Redux를 사용하기 위해 store 및 middleware 적용
```jsx
import React from "react";
import ReactDOM from "react-dom";
import { createStore, applyMiddleware } from "redux";
import { Provider } from "react-redux";
import thunk from "redux-thunk";
import rootReducer from "./modules/index";
import App from "./App";

const store = createStore(rootReducer, applyMiddleware(thunk));

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById("root")
);
```
- 그리고 rootReducer로 여러가지 redux에서의 reducer를 묶는 역할
```jsx
import { combineReducers } from "redux";
import account from "./account/account";

const rootReducer = combineReducers({ account });

export default rootReducer;
```
- 이 redux에서 쓰기 위한 여러가지 action 함수 처리
```jsx
import { fetchUser } from "./api";

// 액션
const FETCH_USER_REQUEST = "FETCH_USER_REQUEST";
const FETCH_USER_SUCCESS = "FETCH_USER_SUCCESS";
const FETCH_USER_FAILURE = "FETCH_USER_FAILURE";

// 액션 생성 함수
export const fetchUserRequest = () => ({
  type: FETCH_USER_REQUEST,
});

export const fetchUserSuccess = ({ name, email }) => ({
  type: FETCH_USER_SUCCESS,
  payload: { name, email },
});

export const fetchUserFailure = () => ({
  type: FETCH_USER_FAILURE,
});

// TODO: thunk 함수 만들기
export const fetchUserThunk = () => {};

const initialState = {
  loading: false,
  name: "",
  email: "",
};

export default function counter(state = initialState, action) {
  switch (action.type) {
    case FETCH_USER_REQUEST:
      return {
        ...state,
        loading: true,
      };
    case FETCH_USER_SUCCESS:
      return {
        loading: false,
        name: action.payload.name,
        email: action.payload.email,
      };
    case FETCH_USER_FAILURE:
      return initialState;
    default:
      return state;
  }
}
```
- 이를 아래의 App.js에서 활용할 수 있음
```jsx
import { useSelector, useDispatch } from "react-redux";
import { fetchUser } from "../src/modules/account/api";
import {
  fetchUserRequest,
  fetchUserSuccess,
  fetchUserFailure,
} from "./modules/account/account";

function App() {
  const account = useSelector((state) => state.account);
  const { loading, name, email } = account;
  const dispatch = useDispatch();

  const handleClick = async () => {
    dispatch(fetchUserRequest());
    try {
      const res = await fetchUser();
      dispatch(fetchUserSuccess({ name: res.name, email: res.email }));
    } catch {
      dispatch(fetchUserFailure());
    }
  };

  return (
    <div className="App">
      <button onClick={handleClick}>User 정보 가져오기</button>
      {loading ? (
        <p>loading...</p>
      ) : name && email ? (
        <>
          <p>이름 : {name}</p>
          <p>이메일 : {email}</p>
        </>
      ) : null}
    </div>
  );
}

export default App;
```
- 여기서 추가로 redux-thunk를 활용해서 App에 있는 비즈니스 로직을 분리하고, UI에서는 UI만 업데이트하게끔 만들 것임
```jsx
import { fetchUser } from "./api";

// 액션
const FETCH_USER_REQUEST = "FETCH_USER_REQUEST";
const FETCH_USER_SUCCESS = "FETCH_USER_SUCCESS";
const FETCH_USER_FAILURE = "FETCH_USER_FAILURE";

// 액션 생성 함수
export const fetchUserRequest = () => ({
  type: FETCH_USER_REQUEST,
});

export const fetchUserSuccess = ({ name, email }) => ({
  type: FETCH_USER_SUCCESS,
  payload: { name, email },
});

export const fetchUserFailure = () => ({
  type: FETCH_USER_FAILURE,
});

// TODO: thunk 함수 만들기
export const fetchUserThunk = () => {
  return async (dispatch) => {
    dispatch(fetchUserRequest());
    try {
      const res = await fetchUser();
      dispatch(fetchUserSuccess({ name: res.name, email: res.email }));
    } catch (e) {
      dispatch(fetchUserFailure());
    }
  };
};

const initialState = {
  loading: false,
  name: "",
  email: "",
};

export default function counter(state = initialState, action) {
  switch (action.type) {
    case FETCH_USER_REQUEST:
      return {
        ...state,
        loading: true,
      };
    case FETCH_USER_SUCCESS:
      return {
        loading: false,
        name: action.payload.name,
        email: action.payload.email,
      };
    case FETCH_USER_FAILURE:
      return initialState;
    default:
      return state;
  }
}
```
```jsx
import { useSelector, useDispatch } from "react-redux";
import { fetchUser } from "../src/modules/account/api";
import {
  fetchUserRequest,
  fetchUserSuccess,
  fetchUserFailure,
  fetchUserThunk,
} from "./modules/account/account";

function App() {
  const account = useSelector((state) => state.account);
  const { loading, name, email } = account;
  const dispatch = useDispatch();

  // const handleClick = async () => {
  //   dispatch(fetchUserRequest());
  //   try {
  //     const res = await fetchUser();
  //     dispatch(fetchUserSuccess({ name: res.name, email: res.email }));
  //   } catch {
  //     dispatch(fetchUserFailure());
  //   }
  // };

  const handleClick = () => {
    dispatch(fetchUserThunk());
  }

  return (
    <div className="App">
      <button onClick={handleClick}>User 정보 가져오기</button>
      {loading ? (
        <p>loading...</p>
      ) : name && email ? (
        <>
          <p>이름 : {name}</p>
          <p>이메일 : {email}</p>
        </>
      ) : null}
    </div>
  );
}

export default App;
```
- 위와 같이 redux-thunk를 사용해서 최적화를 할 수 있음

### 상태관리 도구들 소개(Recoil, Jotai, constate)
- Recoil
  - 리액트 팀에서 직접 만든 상태관리 라이브러리
  - 비동기 데이터 통신을 위한 기능 제공
  - React 내부에 접근이 가능하여 동시성 모드, Suspense등을 손쉽게 지원
  - [공식문서](https://recoiljs.org/ko/docs/introduction/core-concepts)
- Jotai
  - Recoil에 영향을 받아 일본에서 만들어진 라이브러리
  - [공식문서](https://jotai.org/docs)
- constate
  - React Context + State
  - Context의 단점을 개선
  - [공식문서](https://github.com/diegohaz/constate)    
