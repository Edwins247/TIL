## TIL

### 컴퓨터의 구성 요소
- 컴퓨터 구조라는 것은 4개의 컴퓨터 부품이 핵심, CPU, RAM, 보조기억장치, 입출력장치
- 그 부품이 필요한 이유는 데이터를 관리하기 위해서고 그 데이터 관리는 명령어를 통해서함
- CPU(중앙처리장치) : 컴퓨터의 두뇌 역할을 하는 장치, 명령어를 해석하고 연산을 수행하여 프로그램을 실행함
- RAM(주기억장치) : 작업 중인 데이터를 임시로 저장하는 고속 메모리, CPU가 직접 접근하여 데이터를 빠르게 읽고 씀
- 보조기억장치(저장장치) : 데이터를 영구적으로 저장하는 장치, CPU가 직접 접근하지 않고, RAM을 거쳐 데이터를 주고 받음
- 입출력 장치 : 사용자가 데이터를 입력하고, 컴퓨터가 처리한 결과를 출력하는 장치(input: 키보드, 마우스, 마이크 등 / output: 모니터, 프린터 등)

#### CPU(Central Processing Unit)
- 명령어를 해석하고 연산을 수행하여 프로그램을 실행
- 주요 구성 요소
  - 연산 장치(ALU, Arithmetic Logic Unit) : 덧셈, 뺼셈, 논리 연산 등을 수행
  - 제어 장치(CU, Control Unit) : 명령을 해석하고 실행 순서를 제어
  - 레지스터(Register) : 빠른 데이터 저장을 위한 초고속 메모리 공간
- 속도를 결정하는 요소
  - 클럭 속도(Hz), 코어 개수, 캐시 메모리 크기
 
#### RAM(Random Access Memory)
- 작업 중인 데이터를 임시로 저장하는 고속 메모리
- CPU가 직접 접근하여 데이터를 빠르게 읽고 씀
- 전원이 꺼지면 저장된 데이터가 사라지는 휘발성(volatile) 메모리
- 용량이 클수록 다중 작업 성능이 좋아짐
- DRAM(Dynamic RAM), SRAM(Static RAM) 등의 종류가 있음

#### CPU와 RAM
- 아래와 같은 매커니즘이 이루어짐
1. CPU의 제어장치가 메모리의 주소1에 저장된 명령어를 읽기 위해서 메모리에 "메모리 읽기" 제어 신호를 보냄
2. 주소1에서 읽어온 명령어를 레지스터에 저장
  1) 제어장치는 명령어를 해석하여 주소3, 주소4의 데이터가 필요하다고 판단
  2) 제어장치는 주소3과 주소4의 데이터를 읽기 위해 메모리 읽기 제어 신호를 보냄
3. 메모리는 주소3과 주소4 데이터를 CPU에 전달하여 레지스터에 저장됨
  1) ALU는 데이터 연산을 수행
  2) 계산 결과값을 레지스터에 저장
4. 제어장치는 다음 명령어를 위한 메모리 읽기 제어 신호 전달
5. 주소2의 명령어를 레지스터에 저장
  1) 제어장치는 계산 결과를 메모리에 저장해야 한다고 판단
6. 메모리에 메모리 쓰기 제어 신호와 함께 결과값을 전달

#### 보조기억장치
- 데이터를 영구적으로 저장하는 장치
  - CPU가 직접 접근하지 않음
  - RAM을 거쳐 데이터를 주고 받음
- 종류
  - HDD(Hard Disk Drive) : 자기 디스크를 이용한 저장 장치, 저렴하지만 속도가 느림
  - SSD(Solid State Drive) : 반도체 기반 저장 장치, 빠르지만 가격이 비쌈
  - 외장 HDD, SSD, USB, SD 카드 : 휴대용 저장 장치

#### 입출력 장치
- 사용자가 데이터를 입력하고, 컴퓨터를 처리한 결과를 출력하는 장치
- 입력장치(input) : 키보드, 마우스, 마이크 등
- 출력장치(output) : 모니터, 프린터 등
- 입출력 혼합 장치(I/O Device) : USB 메모리, 네트워크 장치 등

#### 메인보드와 시스템 버스
- 메인 보드(또는 마더보드)는 컴퓨터의 중심 회로 기판
  - CPU, RAM 등 모든 부품을 연결하는 역할
  - 각 부품 간 데이터 전송을 가능하게 하는 시스템 버스 포함
  - 전력 공급 및 신호 전달 역할 수행  
  - 추가 기능을 확장할 수 있는 SATA 포트 등 제공
- 시스템 버스는 CPU, 메모리, 저장 장치 등 부품 간 데이터를 주고 받는 통로
  - 컴퓨터 내부에서 데이터가 이동하는 고속도로
  - 데이터를 전달하는 데이터 버스, 메모리를 지정하는 주소 버스, 명령과 제어 신호를 전달하는 제어 버스
  - 제어 버스 : 메모리 읽기 신호
  - 데이터 버스 : 100, 200, 300
  - 주소 버스 : 데이터를 저장할 주소
 
-------

### 컴퓨터가 사용하는 데이터(0과 1)
- 컴퓨터는 오직 0과 1만 이해함, 컴퓨터의 정보 단위는 "비트"임
- Bit: Binary Digit
  - 컴퓨터에서 정보를 표현하는 가장 작은 단위
  - 오직 두 가지 값만 가질 수 있음, 바로 0 또는 1
- 컴퓨터는 전기의 흐름(있음/없음)으로 데이터를 표현함
  - 전압이 있는 상태 -> 1
  - 전압이 없는 상태 -> 0
- 즉, 컴퓨터는 모든 데이터를 비트의 조합으로 표현함
- 이 비트에 따라서 2^n 가지 정보를 표현할 수 있음
- 비트 단위가 커지면? 바이트, 킬로바이트, 메가바이트, 기가바이트 등으로 표현
- 컴퓨터는 모든 데이터를 비트(0 또는 1)으로 표현, 비트가 모이면 사람이 이해하는 숫자 등으로도 표현할 수 있음
- 사람은 기본적으로 10진법을 사용하고 컴퓨터는 0또는 1만 사용하는 이진법이라는 숫자 체계를 사용함

#### 왜 컴퓨터는 이진법을 사용할까?
1. 하드웨어 구조 때문에 전기가 흐르면 1, 흐르지 않으면 0 -> 표현이 단순하고 안정적
2. 신호 처리 오류 감소 -> 2가지 상태만 구분하면 되므로 신호가 명확함
3. 논리 회로 구현이 용이 -> AND, OR, NOT과 같은 논리 연산이 0과 1로 쉽게 구현됨

#### 2진수의 음수 표현
- 컴퓨터는 덧셈, 뺄셈, 비교 연산 등을 수행해야함, 양수뿐만 아니라 음수도 이진수로 표현할 필요가 있음
- 하지만 컴퓨터는 0과 1만 알기 떄문에 특별한 방식으로 음수를 표현해야함
1. 부호-절대값 : 가장 앞 비트를 부호로 사용(0:양수, 1:음수)
2. 1의 보수 : 비트를 반전시켜 음수 표현
3. 2의 보수 : 실제 컴퓨터에서 가장 많이 사용하는 방식
- 2의 보수는 비트를 반전(1의 보수)하고 +1을 더한 값
  - 숫자 3은 0011인데 1의 보수 -> 1100 -> +1을 더하여 1100 + 0001 = 1101
  - 따라서 -3의 2의 보수 표현은 1101
- 하지만 1101은 13일수도 있고 -3일 수도 있는데, 이는 몇 비트이고 어떤 방식으로 해석하느냐에 따라 달라질 수 있음
- 컴퓨터는 비트만 보고 자동으로 값을 판단 못함, 자료형 등의 문맥이 필요함

#### 16진법
- 이진수 표현이 너무 길고 읽기 어렵거나, 2진수 4자리는 16진수 1자리로 변환이 쉽고 일관되며, 메모리 주소, 색상 코드 오류 코드 등의 16진법이 많이 사용됨
- 16진법인 이유는 컴퓨터는 2진수로 동작하는 점과 2진수는 길고 보기 불편하기에 이를 결국 사람이 보기 쉽게 2진수를 간단하게 묶어서 표현할 방법이 필요했음
- 묶기 위해서는 결국 2진수와 궁합이 잘 맞는 진법이어야 하기에 16진법이 됨
- 16진법은 2진수 4자리 = 1자리로 정확히 대응됨, 한 번에 4비트씩 짤라서 딱 1자리의 16진수로 바꿀 수 있음, 간편하고 가독성도 좋음
- 예전에는 8진법도 많이 씀, 하지만 3비트는 컴퓨터 구조에 딱 맞지 않아 비효율적임, 특히 16비트 주소 체계, 32비트 CPU등과 맞추기에는 4비트 단위가 훨씬 자연스러움
- 32진법도 이론상 가능하나 현실적으로 한계가 있는데 먼저 문자 체계의 확장이 필요하고, 다른 이유로는 호환성이 꺠짐(이미 16진수 기반의 최적화됨)
- 그래도 Base32 인코딩과 같은 특수한 목적으로는 사용하는 분야가 있음

#### 인코딩과 디코딩
- 결국 우리가 사용하는 문자, 이미지, 파일, 영상도 모두 결국은 컴퓨터 입장에서는 0과 1, 즉 이진수의 조합일 뿐임
- 이렇게 사람이 이해하는 정보를 컴퓨터가 이해할 수 있는 형태로 바꾸는 과정과 그 반대의 과정도 필요함
- 인코딩(Encoding)
  - 사람이 사용하는 정보(문자, 이미지 등)를 컴퓨터가 이해할 수 있도록 변환하는 과정
  - 결과는 결국 0과 1로 된 binary 데이터, 텍스트의 경우 문자 -> 숫자 -> 2진수로 변경
  - 주요 문자 인코딩 방식
    - ASCII: 영어 알파벳, 숫자, 특수 기호만 표현(1바이트)
    - UTF-8: 전 세계 모든 문자 표현 가능(1~4바이트 유동적)
- 디코딩(Decoding)
  - 컴퓨터가 처리한 binary 데이터를 사람이 이해할 수 있는 정보로 변환하는 과정
  - 인코딩의 반대과정, 잘못된 인코딩/디코딩이 발생하면 문자가 꺠지거나 잘못된 결과가 도출됨
- 아스키코드(Ascii)
  - 컴퓨터가 영문 문자와 숫자, 특수기호 등을 숫자로 표현할 수 있도록 만든 문자 인코딩 체계
  - 각 문자를 고유한 숫자(0~127)로 매핑되며 7비트로 표현됨
  - 7비트로 표현할 수 있는 개수는 2^7 = 128개
- 유니코드(Unicode)
  - 전 세계 모든 문자(글자, 기호, 이모지 등)을 하나의 통일된 기준으로 표현하기 위해 만든 문자 체계
  - 기존 ASCII 코드는 영어권 언어를 위해 작성된 문자 체계라서 국가마다 다른 문자 인코딩을 사용하며 ASCII 코드는 비영어권 문자에서는 사용할 수 없음
  - 문자 꺠짐, 호환성 오류, 복잡한 처리가 발생함 따라서 모든 언어의 문자를 하나의 통일된 코드로 정의한 것이 바로 유니코드
  - 범위 : U+0000 ~ U+10FFFF, 각 문자에 고유한 번호를 부여함 : 'A' -> U+0041, '가' -> U+AC00
- UTF-8(Unicode Transformation Format - 8 bit)
  - 유니코드를 실제로 저장하고 전송할 수 있게 만든 인코딩 방식 중 하나
  - 유니코드는 문자에 고유 번호(코드 포인트)만 정의함, 저장/전송을 위해서는 코드 포인트를 0과 1로 변환하는 방식(인코딩)이 필요함
  - 그 중에서 가장 많이 사용하는 방식이 UTF-8임
  - 가변 길이 인코딩 즉 문자마다 1~4바이트를 사용함, 영문은 ASCII와 동일하게 1바이트로 호환성이 좋음, 다국어 지원 가능함(한글, 일본어, 이모지 등 모두 표현 가능함)

-----

### 프로그래밍 언어에서의 인코딩
- 프로그래밍 언어도 마찬가지로 컴퓨터에 명령을 하기 위해 작성하는 코드도 사람이 사용하기 편하게 만들어진 언어임
- 이 언어를 컴퓨터가 이해하기 좋게 바꿔주는 과정이 필요함(코드 인코딩)
- 여기서 사람(개발자)이 이해하기 쉬운 언어를 고급 언어라고 함(high-level language)
- 컴퓨터가 이해할 수 있는 언어는 저급 언어 또는 기계어라고 함(low-level language)

#### 고급 언어와 저급 언어
- 고급 언어, High-level language
  - 사람이 이해하기 쉬운 자연어에 가까운 문법과 구조를 가진 언어
  - 직관적인 문법(if, for, print 등)으로 사람이 쓰기 편함
  - 어떤 컴퓨터에서도 비슷하게 동작하므로 하드웨어와 독립적으로 사용할 수 있음
  - 기계어로 번역되어야 실제로 사용 가능하기 때문에 컴파일 또는 인터프리팅이 필요함
  - Python, Java, JavaScript, C, Kotlin 등의 언어가 있음
- 저급 언어, Low-level language
  - 기계어에 가까운 언어로 컴퓨터 하드웨어와 밀접하게 연관되어 있음
  - 어셈블리어(Assembly)와 기계어(Machine code)가 있음
  - 하드웨어를 제어하기에 적합하며 속도가 빠르고, 메모리를 절약할 수 있는 장점이 있음
  - 하지만 사람이 읽고 쓰기에는 매우 어려움
- 어셈블리어(Assembly)
  - 기계어 명령어를 사람이 읽기 쉽게 기호로 표현한 언어
  - CPU마다 어셈블리어 문법이 다름(예 : x86, ARM 등)
  - 사람이 메모리 주소, 레지스터 등을 직접 다룰 수 있음
- 기계어(Machine code)
  - 컴퓨터가 직접 실행할 수 있는 2진수(0과 1)코드
 
#### 저급 언어를 알아야 하는 이유
1. 프로그램은 결국 기계어로 실행됨
  1) 아무리 Java, Kotlin, Python과 같은 고급 언어로 코드를 작성하더라도, 결국은 기계어(0과 1)로 번역되어 CPU에서 실행됨
  2) 고급 언어는 추상화가 되어 내부 동작을 쉽게 숨기지만 메모리 구조, 연산 방식, 성능 최적화 등을 이해하려면 결국 기계 수준에서의 동작 방식을 알아야 함
  3) 예를 들어, List<String>을 사용할 때 내부적으로 메모리에 어떻게 할당이 되고, 어떤 방식으로 순회되는지를 알지 못하면 성능 최적화를 할 수 없음
2. 성능, 메모리 최적화, 하드웨어 연동을 이해하려면 필수임
  1) 성능이 중요한 분야(게임, 서버, 임베디드 등)에서는 CPU 연산 방식, 메모리 구조, 캐시, 레지스터를 이해해야 진짜 성능을 끌어 올릴 수 있음
  2) 저급 언어를 통해 메모리의 흐름, 스택/힙 구조, 함수 호출 방식 등을 깊이 있게 배울 수 있음

#### 고급 언어를 저급 언어로 변환하기
- 컴파일러와 인터프리터는 고급 언어를 컴퓨터가 이해할 수 있는 저급 언어로 변환하는 핵심 도구임
- 컴파일러(Compiler)
  - 전체 소스 코드를 한 번에 분석해서 기계어로 번역하는 프로그램
  - 작동 방식
    1. 고급 언어 코드(예: C언어)를 개발자가 작성함
    2. 컴파일러가 전체 코드를 분석
    3. 기계어(exe, out 등의 실행 파일)로 번역
    4. 번역된 파일을 실행하면 프로그램이 동작
  - 특징
    - 이미 번역된 기계어를 실행하기 떄문에 실행 속도가 빠름
    - 컴파일 단계에서 문법 오류를 확인하기 때문에 사전 에러를 체크할 수 있음
    - 한 번에 전체를 분석하기 때문에 번역하는 시간이 필요할 수 있음
- 인터프리터(Interpreter)
  - 소스 코드를 한 줄씩 읽고 바로 실행하는 방식
  - 작동 방식
    1. 고급 언어 코드(예: Python)을 개발자가 직접 작성함
    2. 인터프리터가 한 줄씩 읽으면서 바로 실행
    3. 기계어로 변환된 코드는 메모리에만 일시적으로 존재
  - 특징
    - 컴파일 없이 바로 실행하기 떄문에 실행 준비가 빠름
    - 실시간으로 해석하기 때문에 실행 속도 자체는 느릴 수 있음
    - 디버깅에 유리함
- 하이브리드 방식(Java)
  - Java, Kotlin은 컴파일과 인터프리터를 혼합한 방식을 사용함
  - 컴파일러로 바이트코드(.class)로 변환
  - JVM(Java Virtual Machine)에서 인터프리팅
  - JVM 작동 순서
    - Java 코드 작성 -> 컴파일 -> 바이트코드(.class) -> JVM에서 실행
- 명령어
  - 컴퓨터에서 실행되는 기계어 명령어는 보통 다음과 같은 구조로 이루어짐
  - [연산코드(Opcode) | 오퍼랜드(Operand)]        
  - 연산코드(Opcode, Operation Code)
    - CPU가 수행될 동작(연산 종류)를 나타내는 코드(덧셈, 곱셈, 데이터 이동, 비교, 분기 등)
    - 기계어에서는 2진수 또는 16진수로 표현됨
  - 오퍼랜드(Operand)
    - Opcode가 동작을 수행할 대상(데이터 또는 주소)
    - 보통 연산에 필요한 값이나 주소를 의미함

#### 주소 지정 방식
- 오퍼랜드가 실제로 어디에 있는지를 CPU가 해석하는 방식
- 왜 중요한가?
  - 같은 명령어라도 오퍼랜드의 위치에 따라 완전히 다른 의미가 됨
  - 성능, 효율, 유연성에도 큰 영향을 미침
- 다양한 주소 지정 방식
  - 즉시(Immediate)
    - 오퍼랜드 자체가 값(MOV AX,5 -> 5를 바로 사용)
  - 직접(Direct)
    - 오퍼랜드는 메모리 주소(MOV AX, [2000] -> 주소 2000의 값을 가져옴)
  - 간접(Indirect)
    - 레지스터 안의 값이 주소(MOV AX, [BX] -> BX가 가리키는 주소의 값을 가져옴)
      
