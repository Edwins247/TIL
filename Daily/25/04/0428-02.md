## TIL

### CPU 개요
- CPU, Central Processing Unit, 컴퓨터의 두뇌로 명령어를 해석하고 실행하는 핵심 부품("명령어" -> Opcode, Operand)
- CPU의 주요 역할
  - 연산 수행 : 덧셈, 뺄셈, 논리 연산 등의 데이터를 계산하고 처리
  - 명령어 해석 : 메모리에 저장된 명령어를 읽어 무엇을 해야 하는지 판단하고 실행
  - 데이터 이동 제어 : 메모리 <-> 레지스터 <-> 입출력 장치 간 데이터 흐름 조정
- CPU의 기본 구성 요소
  - 연산장치(ALU) : 산술 및 논리 연산 수행(덧셈, 비교 등)
  - 제어 장치(CU) : 명령어를 해석하고 각 부품에 신호 전달
  - 레지스터(Register) : 초고속 임시 저장소(데이터, 주소 저장)
  - 클럭(Clock) : 명령 실행 속도를 결정(Hz 단위)

#### ALU(Arithmetic Login Unit)
- 산술 및 논리 연산을 수행하는 CPU의 핵심 하드웨어 회로
- CPU 내부에서 데이터를 계산하거나 논리적으로 판단하는 모든 작업은 ALU에서 수행됨
- Arithmentic : 산술 연산(덧셈, 뺼셈, 곱셈, 나눗셈 등)
  - ADD: 덧셈 / SUB: 뺄셈 / INC: 1 증가 / DEC: 1 감소 / MUL: 곱셈 / DIV: 나눗셈 
- Logic : 논리 연산(AND, OR, NOT, XOR 등)
  - AND: 두 값이 모두 1이면 1 / OR: 둘 중 하나라도 1이면 1 / XOR: 두 값이 다르면 1 / NOT: 0이면 0, 1이면 0 / SHL: Shift Left(왼쪽 시프트) / SHR: Shift Right(오른쪽 시프트)   
- CPU가 처리하는 대부분의 연산은 ALU를 통해 이루어짐, 제어 장치(CU)가 ALU에게 무엇을 연산하라 신호를 보내면, ALU가 실제 연산을 수행함
- 계산을 하기 위해서는 피연산자와 수행할 연산이 필요함, 피연산자는 레지스터를 통해, 수행할 연산은 제어장치를 통해 제어 신호를 받음
- 연산을 수행한 결과는 어떠한 숫자, 문자 값이 될 수도 있고 메모리 주소 값이 될 수도 있음
- 결과값은 바로 메모리에 저장되지 않고, 레지스터에 임시 저장됨 왜냐하면 메모리에 바로 저장이 되면 CPU는 메모리에 더 자주 접근하게 되며 속도가 느려질 수 있음
- 결과값과 더불어 플래그를 내보냄(연산 결과에 대한 추가적인 정보, 음수 결과, 큰 결과 등)
- 상태 플래그(Status Flag)
  - 연산 결과에 대한 추가적인 정보를 플래그라고 함
  - 부호 플래그(Sign, S): 연산한 결과의 부호를 나타냄(1: 음수, 0: 양수)
  - 제로 플래그(Zero, Z): 연산 결과가 0인지 나타냄(1: 0맞음, 0: 0아님)
  - 캐리 플래그(Carry, C): 연산 결과 올림수나 빌림수가 발생했는지를 나타냄(1: 자리올림/내림 발생)
  - 오버플로우 플래그(Overflow, O): 오버플로우가 발생했는지를 나타냄(1: 오버플로우 발생)

#### 제어 장치
- Control Unit, CU
  - 제어 장치는 CPU 내부에서 모든 동작의 흐름을 통제하고 조정하는 역할을 하는 유닛
  - CPU의 지휘자 또는 감독관
- 핵심 역할
1. 명령어 해석 : 주기억장치(RAM)에서 가져온 기계어 명령어를 해석(어떤 연산(Opcode)을 해야하는지 판단)
2. 제어 신호 생성 : 해석된 명령어에 따라 CPU 내부 구성요소에 신호를 전달하여 동작을 유도
3. 연산 흐름 제어 : 명령어 실행 순서를 제어(분기, 조건문 처리 등 담당)

#### 클럭(Clock)
- 클럭은 CPU 내부의 모든 동작을 동기화하는 주기적인 신호(CPU의 박자, 심장 박동으로 이야기할 수 있음)
- 클럭의 역할
  - CPU는 수많은 작업을 매우 빠르게 수행하지만, 모든 작업은 정해진 순서에 따라 이루어져야 함
  - 그래서 CPU는 내부 동작을 일정한 리듬으로 진행하는데, 이 리듬을 만들어주는 신호가 바로 클럭 신호임
- 클럭 속도
  - 단위 : Hz(헤르츠)
  - 1Hz = 1초에 1번 신호 발생
  - 1GHz = 1초에 10억번의 신호 발생
  - 즉, 클럭 속도가 높을수록 초당 더 많은 연산을 할 수 있으며, 일반적으로 CPU의 성능을 판단하는 지표 중 하나
- 그럼 클럭이 높으면 무조건 좋은가?
  - 클럭 속도는 CPU 성능에 중요한 요소이긴 하지만 CPU 성능 = 클럭 속도만으로는 결정되지 않음
  - 명령어 당 처리량도 중요함(IPC, Instructions Per Cycle)
  - CPU는 클럭 1회당 얼마나 많은 명령어를 처리하는지도 중요함
  - 아무리 클럭이 빨라도 한 클럭에 처리하는 명령이 적으면 느릴 수 있음
  - 또한 클럭이 높아질수록 발열 증가 -> 과열 위험 -> 성능 하락, 동시에 전력 소비도 증가함

#### 레지스터(Register)
- 레지스터는 CPU 내부에 존재하는 초고속 임시 기억장소, 주로 명령어 수행 중 필요한 데이터나 주소를 일시적으로 저장함(CPU가 가장 먼저, 가장 자주 접근하는 메모리)
- 특징
  - 위치 : CPU 내부(ALU의 제어 장치 근처)
  - 속도 : 가장 빠른 메모리(캐시나 RAM보다 훨씬 빠름)
  - 용량 : 매우 작음(수십 개, 보통 수 바이트 ~ 수십 바이트 수준)
  - 역할 : 명령어 수행에 필요한 데이터, 주소, 상태 정보 등을 저장
- 즉, 레지스터는 속도를 위해 용량을 포기한 메모리
- 레지스터는 왜 필요할까?
  - CPU가 연산을 수행하려면 계산할 데이터를 어디낙에 저장해야함
  - RAM은 상대적으로 느리고 접근 비용이 크기 때문에 매번 사용하기에 어려움이 있음
  - CPU 내부에 초고속 임시 저장(레지스터)을 둬서 효율적으로 연산을 처리함
- 레지스터는 용도에 따라 여러 가지로 나뉨
  - 일반 목적 레지스터(연산에 필요한 데이터를 임시로 저장하는 레지스터)
  - 특수 목적 레지스터(CPU의 상태나 제어 정보를 담는 레지스터)
    - 프로그램 카운터(PC, Program Counter)
      - 현재 실행중인 명령어 다음에 CPU가 실행해야 할 명령어의 주소를 저장하는 레지스터(즉, CPU가 다음에 어디로 가야할지 기억하는 역할) 
    - 명령어 레지스터(IR, Instruction Register)
      - 현재 CPU가 실행하고 있는 명령어 자체를 저장하는 레지스터(프로그램 카운터가 "어디로 갈지"를 가리킨다면, 명령어 레지스터는 "지금 무엇을 하고 있는지"를 담고 있음)   
    - 메모리 주소 레지스터(MAR, Memory Address Register)
      - CPU가 메모리에 접근할 때 "어느 주소에 접근할 것인지"를 저장하는 특수 목적 레지스터
      - CPU가 "이 주소에 있는 데이터를 읽어와야지!" 또는 "이 주소에 데이터를 저장해야지!"할 때, 그 주소 정보를 임시로 보관하는 저장소
    - 메모리 버퍼 레지스터(MBR, Memory Buffer Register)
      - CPU가 메모리와 데이터를 주고 받을 때 읽어온 데이터 또는 써야(write)할 데이터를 임시로 저장하는 레지스터(메모리와 CPU 사이의 데이터 통로 역할을 함) 
    - 플래그 레지스터(Status Register)
  - 스택 관련 레지스터(함수 호출, 지역 변수, 리턴 주소 등을 저장)
- 레지스터 동작 원리
  1. CPU로 실행할 프로그래밍 주소 100부터 주소 200까지 있다고 가정(주소 100에는 1101(2)가 저장되어 있음)
  2. 프로그램 카운터에 100이 저장됨 즉, 메모리에서 가져올 명령어가 주소 100에 있다는 것을 의미함
  3. 주소 100을 읽어 들이기 위해서는 주소 버스로 주소 100을 내보내야함(메모리 주소 레지스터에는 100이 저장됨)
  4. 메모리 읽기 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐
  5. 데이터 버스를 통해 메모리 버퍼 레지스토로 전달됨, 프로그램 카운터는 증가되어 다음 명령어를 읽을 준비를 함
  6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동함
- 범용 레지스터
  - CPU가 연산에 직접 사용하는 임시 공간으로, 데이터, 주소, 중간 결과 등 다양한 용도로 활용되는 가장 일반적인 레지스터
  - 왜 범용? 특정 기능에 제한되지 않고, 계산, 데이터 이동, 메모리 주소 저장 등 다양한 용도로 사용할 수 있음
  - 즉, 제어 레지스터처럼 고정된 역할이 아니라, 프로그래머가 자유롭게 활용할 수 있는 레지스터
- 플래그 레지스터
  - CPU가 연산을 수행한 뒤에 그 결과의 상태를 기록하는 레지스터
  - 예: 결과가 0인가? 오버플로우가 발생했는가? 음수인가? 자리올림이 있었는가? 등
  - 이 정보들은 이후의 조건 분기(jump), 반복, 비교 연산에 매우 중요하게 사용됨

#### 스택 주소 지정 방식
- 스택 포인터는 스택이라는 메모리 공간의 가장 끝(top)을 가리키는 특수 목적 레지스터
- 마지막으로 push(저장)된 데이터의 위치 또는 다음으로 pop(꺼낼) 위치를 가리키는 레지스터
- 스택 구조
  - 후입선출(LIFO, Last In First Out) 구조의 메모리 영역
  - Push: 데이터를 스택에 넣기
  - Pop: 데이터를 스택에서 꺼내기
  - 주로 함수 호출, 지역 변수 저장, 리턴 주소 저장 등에 사용됨
- 스택의 위에서부터 주소가 매겨져 있고 Push 할 때마다 아래부터 차례대로 데이터가 저장됨
- 스택 포인터는 제일 꼭대기(top)의 주소를 저장하고 있음

#### 명령어 사이클(Instruction Cycle)이란?
- 일정한 흐름 속에서 CPU는 하나의 명령어를 처리함(그 과정을 명령어 사이클이라함, 그 흐름이 끊어지는 상황을 인터럽트라고 함)
- CPU가 하나의 명령어를 메모리에서 가져와서(fetch), 해석하여(decode), 실행(execute)하는 일련의 과정, 즉, 프로그램 코드를 실제로 CPU가 실행하기 위한 최소 단위 처리 과정임
- 명령어 사이클의 목적
  - 주기억장치(RAM)에 저장된 명령어를 CPU가 순서대로 가져와 해석하고 실행하기 위함
  - 이 과정을 반복하며 프로그램 전체가 실행됨
- 명령어 사이클의 기본 3단계
  1. 가져오기(Fetch)
    1) 명령어를 메모리에서 가져와서 IR에 저장
    2) 프로그램 카운터의 값을 메모리 주소 레지스터로 복사함, 실행할 명령어의 주소를 지정함
    3) 메모리 주소 레지스터의 값을 메모리 버퍼 레지스터로 복사함
    4) 메모리 버퍼 레지스터의 명령어를 IR로 저장
    5) 프로그램 카운터를 증가시키며 다음 명령어를 위한 준비를 함
  2. 해석(Decode)
    1) 명령어의 Opcode와 Operand 분석
    2) IR에 저장된 명령어의 연산 코드(Opcode)와 피연산자(Operand)를 분석
    3) 제어 장치(CU)가 무슨 연산을 해야 하는지 판단
    4) 필요한 제어 신호를 생성
  3. 실행(Execute)    
    1) ALU 또는 관련 장치를 통해 명령 수행
    2) ALU가 연산 수행, 메모리 접근
    3) 조건 분기, 점프, 함수 호출 등의 흐름 제어
    4) 결과를 레지스터나 메모리에 저장

#### 인터럽트(Interrupt)란?
- CPU가 현재 실행 중인 작업을 잠시 멈추고, 외부나 내부에서 발생한 사건을 우선적으로 처리하도록 흐름을 전환시키는 매커니즘(즉, 지금 급한 일이 생겼으니, 일단 이것부터 처리해주세요!하며 CPU에게 알리는 신호)
- 인터럽트가 필요한 이유
  1. 외부 이벤트에 즉각 반응해야 하기 떄문에
    1) 키보드가 눌리거나 마우스를 클릭할 때
    2) 하드디스크에서 데이터 읽기 완료 시
    3) 네트워크로부터 데이터 수신 시
    -> 이런 이벤트는 CPU가 예측할 수 없는 시점에 발생
  2. CPU 자원을 낭비하지 않기 위해
    1) 이벤트가 올 때까지 계속 기다리는 것(Polling)은 비효율적
    2) 인터럽트를 사용하면 CPU는 평소 할 일을 하다가, 이벤트가 오면 잠시 응답하면 됨
- 인터럽트의 분류
  - 발생 원인 기준
    - 하드웨어 인터럽트 : 외부 장치에서 발생한 신호(예: 키보드 입력, 마우스 클릭 등)
    - 소프트웨어 인터럽트 : 프로그램 코드 실행 중 발생(예: 예외, 시스템 호출 등)
  - 타이밍 기준
    - 동기 인터럽트 : 명령 실행 중 발생으로 예측이 가능함(예: 0으로 나누기, 잘못된 명령 등)
    - 비동기 인터럽트 : 외부에서 발생으로 예측이 불가능함(예: 키보드 입력, 디스크 I/O 완료 등)
- 인터럽트 처리 흐름(동작 방식)
  1. 인터럽트 발생
    - 장치 또는 CPU 내부에서 인터럽트 요청 신호 발생 
  2. 현재 명령어 완료 후 CPU가 응답
    - 현재 작업을 중단하지 않고 끝낸 후 인터럽트 수신
  3. 현재 상태 저장
    - 프로그램 카운터, 레지스터 값 등 저장
  4. 인터럽트 핸들러 실행
    - 해당 이벤트를 처리하는 코드 실행
  5. 원래 작업 복귀
    - 저장된 상태를 복원하고 중단 지점부터 다시 실행

#### 클럭
- 컴퓨터에서 모든 동작을 일정한 속도로 동기하 시키는 주기적인 전기 신호, 클럭은 CPU가 언제 일할지를 알려주는 박자, 클럭 속도는 CPU가 1초에 몇 번 일할 수 있는지를 나타냄
- 클럭의 역할
  - CPU 동작 동기화 : CPU 내부 모든 회로가 클럭 신호에 맞춰 작동
  - 명령어 실행 타이밍 제어 : 클럭 하나하나가 작업의 한 단계
  - 컴퓨터 전체의 리듬 생성 : 메모리, 버스, 입출력장치 등도 클럭에 동기화됨
- 명령어 사이클은 보통 여러 개의 클럭 사이클로 구성됨
  - 하나의 명령어를 실행
  - 1클럭: 명령어 fetch
  - 2클럭: 명령어 decode
  - 3클럭: 연산 execute
  - 4클럭: 결과 저장 write-back
  - 클럭 1번 = 명령어 1개 처리가 아닐 수도 있음
- 클럭이 높다고 무조건 좋은 것은 아님
- 클럭은 CPU 성능에 영향을 주는 하나의 요소
  - IPC(Instructions Per Cycle): 클럭 한 번에 몇 개의 명령을 처리하나?
  - 코어 수: 동시에 처리할 수 있는 작업의 수
  - 캐시/버스/메모리 속도: 데이터 접근 속도에 영향
  - 발열/전력 효율: 클럭이 높을수록 과열 가능성이 증가
- 실제로는 클럭 x IPC x 코어 수가 CPU 성능을 결정
- 현대 CPU의 전략 : "고클럭"보다 "고효율"
  - 예전: 클럭을 무조건 높이면 성능 향상
  - 현대: 발열, 전력 문제로 무한히 올릴 수 없음, 대신 멀티코어 + 고효율 마이크로아키텍쳐 설계

#### 코어란?
- 코어는 CPU 안에서 실제로 연산을 수행하는 독립적인 처리 장치
- 즉, CPU가 두뇌라면, 코어는 뇌세포 하나라고 볼 수 있음
- 하나의 코어는 자신만의 연산 장치(ALU), 제어 장치(CU), 레지스터를 가지고 있음
- 하나의 명령어 흐름을 독립적으로 실행할 수 있음
- 예전 CPU는? 과거 CPU는 하나의 코어만을 가지고, 한 번에 하나의 작업만 처리할 수 있었음
- 성능을 위해 멀티 코어가 구성됨(멀티 코어란? 하나의 CPU칩 안에 여러 개의 코어를 두고 동시에 여러 작업(프로세스/스레드)을 병렬로 처리할 수 있는 구조
- 멀티 코어의 목적: 속도 향상을 위해 과거에는 클럭을 높였지만 발열, 전력, 한계에 부딪치자, 코어를 여러 개 넣는 방향으로 바꿈
- 싱글 코어와 멀티 코어 비교
  - 싱글 코어는 1개만 처리 가능하지만 멀티 코어는 여러 작업을 병렬 처리할 수 있음
  - 싱글 코어는 멀티 태스킹 성능이 낮으며 멀티 코어는 멀티 태스킹 성능이 높음
  - 싱글 코어는 클럭 증가로 발열이 올라가지만 멀티 코어는 클럭을 낮추고 코어를 늘려 발열이 낮아짐
  - 싱글 코어는 구조가 간단하지만 멀티 코어는 비교적 복잡함
- 코어와 스레드
  - CPU에는 여러 개의 코어(=멀티코어)가 존재함, 그 코어들이 동시에 여러 작업을 처리할 수 있음
  - 그 코어 안에서도, 실제로 작업을 수행하는 최소 실행 단위가 존재하는데 그것이 스레드
  - 코어가 몸통이라고 한다면, 스레드는 그 안에서 움직이는 실행 흐름, 손/발이라고 볼 수 있음
  - 멀티 코어가 하드웨어적 병렬 처리를 가능하게 한다면, 스레드는 그 병렬성을 활용하는 소프트웨어적 실행 단위로 볼 수 있음
- 스레드(Thread)란?
  - 스레드는 프로세스 내부에서 실제로 작업을 수행하는 실행 단위
  - 프로세스는 프로그램 하나(예: 크롬 브라우저, 워드 프로세서, 게임 등)
  - 스레드는 그 프로그램이 작업을 실제로 수행하는 손/발
  - 하나의 프로세스는 하나 이상의 스레드를 가질 수 있음
- 스레드와 프로세스
  - 프로세스(Process)
    - 정의: 실행 중인 프로그램
    - 메모리: 각각 독립된 주소 공간
    - 생성 비용: 높음
    - 자원 공유: 기본적으로 안됨
    - 충돌 시: 서로 간섭 없음
  - 스레드(Thread)
    - 정의: 프로세스 내 실행 흐름
    - 메모리: 같은 주소 공간을 공유
    - 생성 비용: 낮음
    - 자원 공유: 메모리, 파일 등 공유
    - 충돌 시: 동기화 필요
- 멀티 스레드(Multi-thread)란?
  - 하나의 프로세스 안에서 여러 개의 스레드가 동시에 실행되는 구조
    - 병렬로 여러 작업을 처리할 수 있음
    - 작업 분할, 자원 효율적 사용이 가능해짐
  - 멀티 스레드기 필요한 이유
    - 예시1. 웹 브라우저
      - 스레드1: 화면 그리기
      - 스레드2: 사용자 입력 처리
      - 스레드3: 네트워크로 데이터 받기
- 멀티 스레드와 멀티 코어의 관계
  - 멀티 스레드: 여러 흐름이 논리적으로 동시에 동작
  - 멀티 코어: 여러 물리 코어가 존재 -> 진짜 동시 실행 가능
  - 멀티 코어 CPU에서 멀티 쓰레드를 쓰면 진정한 병렬 처리 가능(4코어 CPU에서 4개 스레드를 동시에 실행)
      
