## TIL

### 비동기 프로그래밍
- 비동기적이란, 앞서 JS에서 배웠듯이 작업 처리에 있어서, 특정 프로세스에서 작업이 진행되는 것이 완료되는 것을 알려주는 것은 의미가 없고, 다른 작업을 수행할 수 있게 처리하는 것이 결국 비동기 프로그래밍의 핵심임
- 그래서 이러하게 비동기적으로 처리하는데 있어서 가장 직관적으로 구분해서 처리하는 것은 setTimeout이 있음
- 만약 어떤 코드를 비동기 방식으로 실행시키고 싶다면 이 코드의 실행이 완료될때까지 기다리지 않고, 다음 코드를 실행시킴
- 그리고 이 코드의 실행이 완료(or 성공)되면, 특정 코드를 실행시킴, 이럴 때 Promise 객체를 활용해서 처리함
- 아니면 async/await 키워드를 통해서 비동기 처리를 해줄 수 있음.

### 컴포넌트에서 API 호출하기 - Fetch API & axios
- 먼저 Fetch API를 통해서 API 호출처리를 할 수 있고, 이는 Promise를 리턴해서 그에 따른 결과를 처리할 수 있음
- [참고자료](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API)
- 또한 jsonplaceholder 사이트를 통해서 실제 API 테스트를 할 수 있음([Mock JSON](https://jsonplaceholder.typicode.com/))
- 아래와 같이 Fetch API를 통해 비동기 프로그래밍 및 API 호출을 할 수 있음
```jsx
  const [docs, setDocs] = useState([]);

  useEffect(() => {
    async function fetchData() {
      const res = await fetch(
        "https://jsonplaceholder.typicode.com/posts"
      );
      const result = await res.json();
      console.log(result);
      return result;
    }

    fetchData().then(res => {
      setDocs(res);
    });
  }, []);
```
- 이 때 Axios라는 라이브러리를 사용할 경우 동일하게 API 호출 처리를 할 수 있는데, 이는 JSON 데이터 자동 변환, 요청 및 응답에 대한 인터셉트, 타임아웃도 가능하고 다양한 기능을 지원함
- [공식문서](https://axios-http.com/kr/docs/intro)
- axios도 Promise 기반의 async-await으로 처리함
```jsx
  // api call -> react에 해당하는 글의 목록을 응답 받음.
  const [docs, setDocs] = useState([]);

  useEffect(() => {
    async function fetchData() {
      const result = await axios.get(
        "https://jsonplaceholder.typicode.com/posts"
      );
      console.log(result);
      console.log(result.data);
      return result.data;
    }

    fetchData().then(res => {
      setDocs(res);
    });
  }, []);
```
- axios 사용시, 여러개의 Promise를 처리하는 등 옵션을 활용해서 다양하게 API를 호출할 수 있음
- 그리고 useEffect내에서 API 호출 시 주의할 점이 있는데, useEffect에서 위의 예시처럼 쓰지 않고 바로 async-await으로 쓰면 안됨
- 앞서 useEffect, useState 등 기존의 React의 Hook을 사용해서 했음, 하지만 그렇게 하기에 API 호출에 있어서 로딩 처리, 에러 핸들링 등 여러가지 처리가 필요함
- 이럴 때 자체적으로 커스텀 훅을 만들어서 해볼 수 있음(기존의 useState, useEffect를 쓰지만 이에 대해서 별도의 `use`가 붙은 훅을 만들어서 데이터 처리용으로 별도로 만드는 것)
- [참고자료](https://ko.legacy.reactjs.org/docs/hooks-overview.html#building-your-own-hooks)
- 대표적으로 useFetch라고 커스텀 훅을 만들어서 처리하는 경우가 있음

### swr과 React-Query
- 비동기 로직을 쉽게 처리하는 것에 있어서 swr과 React-Query를 씀, 하지만 이에 대해서 전역 상태 관리까지 같이 고려해야함
- [swr 공식 문서](https://swr.vercel.app/ko/docs/getting-started)
- useSwr은 앞서 말한 useFetch와 유사한 커스텀 훅의 느낌으로 쓸 수 있음, 하지만 여기선 state 처리가 별도로 없음
- 이 swr의 특징은 API 호출 시, 해당하는 response 데이터를 캐싱하는 개념으로 처리를 하는 컨셉을 가지고 있음, 그래서 리렌더링 시 API 호출을 다시 하지 않음 또한 이러한 swr을 나만의 커스텀 훅으로 다시 만들어 볼 수도 있음
- mutate를 통해서 fetching 처리도 추가해서 처리할 수 있음
```jsx
  async function fetcher(url) {
    const result = await axios.get(url);
    console.log(result.data);
    return result.data;
  }

  const { data: docs, error } = useSwr("posts", () => fetcher("https://jsonplaceholder.typicode.com/posts"));

  if (error) return <div>에러가 발생했습니다.</div>;
  if (!docs) return <div>로딩중...</div>;
```
- [React-Query 공식 문서](https://tanstack.com/query/latest/docs/framework/react/overview)
- React-Query도 useSwr과 비슷하게 커스텀 훅처럼 쓸 수 있음
